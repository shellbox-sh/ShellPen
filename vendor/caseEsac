#! /usr/bin/env bash

_SHELLPEN_SHEBANG=("#! /usr/bin/env bash")

_SHELLPEN_PENS=("default")
_SHELLPEN_PEN_SOURCES=("default")
_SHELLPEN_CURRENT_PEN_NAME="default"
_SHELLPEN_CURRENT_PEN_INDEX=0

_SHELLPEN_CURRENT_SOURCE_INDEX=0
_SHELLPEN_CURRENT_SOURCE_NAME="default"
_SHELLPEN_SOURCES=("default")
_SHELLPEN_SOURCECODE=("")
_SHELLPEN_SOURCES_FILE_PATHS=("")
_SHELLPEN_INDENT_LEVELS=(0)
_SHELLPEN_FUNCTION_OPEN=("")
_SHELLPEN_CASE_OPEN=("")
_SHELLPEN_MAIN_FUNCTION=("")

# Public Variables
[ -z "$SHELLPEN_INDENT" ] && SHELLPEN_INDENT="  "

## @command shellpen
shellpen() {
  declare -a __shellpen__mainCliCommands=("shellpen")
  declare -a __shellpen__originalCliCommands=("$@")

## > 🖋️ Generate Shell Script Source Code using a familiar DSL!

  local __shellpen__mainCliCommandDepth="1"
  __shellpen__mainCliCommands+=("$1")
  local __shellpen__mainCliCommands_command1="$1"
  shift
  case "$__shellpen__mainCliCommands_command1" in
    "--")
    ## @command shellpen --
      local __shellpen__mainCliCommandDepth="2"
      __shellpen__mainCliCommands+=("$1")
      local __shellpen__mainCliCommands_command2="$1"
      shift
      case "$__shellpen__mainCliCommands_command2" in
        "blocks")
        ## @command shellpen -- blocks
            local __shellpen__mainCliCommandDepth="3"
            __shellpen__mainCliCommands+=("$1")
            local __shellpen__mainCliCommands_command3="$1"
            shift
            case "$__shellpen__mainCliCommands_command3" in
              "cases")
              ## @command shellpen -- blocks cases
                    local __shellpen__mainCliCommandDepth="4"
                    __shellpen__mainCliCommands+=("$1")
                    local __shellpen__mainCliCommands_command4="$1"
                    shift
                    case "$__shellpen__mainCliCommands_command4" in
                      "close")
                      ## @command shellpen -- blocks cases close
                        if [ "${_SHELLPEN_CASE_OPEN[$_SHELLPEN_CURRENT_SOURCE_INDEX]}" = true ];
                        then
                          shellpen esac
                        fi
                        _SHELLPEN_CASE_OPEN[$_SHELLPEN_CURRENT_SOURCE_INDEX]=false
                      ## @
            
                          ;;
                      "open")
                      ## @command shellpen -- blocks cases open
                        _SHELLPEN_CASE_OPEN[$_SHELLPEN_CURRENT_SOURCE_INDEX]=true
                      ## @
            
                          ;;
                      *)
                        echo "Unknown 'shellpen -- blocks cases' command: $__shellpen__mainCliCommands_command4" >&2
                        return 1
                        ;;
                    esac
              ## @
      
                  ;;
              "closeAll")
              ## @command shellpen -- blocks closeAll
                shellpen -- blocks cases close
                shellpen -- blocks functions close
              ## @
      
                  ;;
              "functions")
              ## @command shellpen -- blocks functions
                    local __shellpen__mainCliCommandDepth="4"
                    __shellpen__mainCliCommands+=("$1")
                    local __shellpen__mainCliCommands_command4="$1"
                    shift
                    case "$__shellpen__mainCliCommands_command4" in
                      "close")
                      ## @command shellpen -- blocks functions close
                        local __shellpen__blocks_functions_close_newLine=$'\n'
                        if [ -n "$SHELLPEN_SOURCE" ]
                        then
                          local __shellpen__blocks_functions_close_sourceIndex=''
                          if ! shellpen -- getSourceIndex "$SHELLPEN_SOURCE" - __shellpen__blocks_functions_close_sourceIndex
                          then
                            shellpen -- errors argumentError '%s\n%s' "Source '$1' does not exist" "Command: shellpen ${__shellpen__originalCliCommands[*]}"
                            return 1
                          else
                            if [ "${_SHELLPEN_FUNCTION_OPEN[$__shellpen__blocks_functions_close_sourceIndex]}" = true ];
                            then
                              shellpen append }
                            fi
                            _SHELLPEN_FUNCTION_OPEN[$__shellpen__blocks_functions_close_sourceIndex]=false
                          fi
                        else
                          if [ "${_SHELLPEN_FUNCTION_OPEN[$_SHELLPEN_CURRENT_SOURCE_INDEX]}" = true ];
                          then
                            shellpen append }
                          fi
                          _SHELLPEN_FUNCTION_OPEN[$_SHELLPEN_CURRENT_SOURCE_INDEX]=false
                        fi
                      ## @
            
                          ;;
                      "open")
                      ## @command shellpen -- blocks functions open
                        if [ -n "$SHELLPEN_SOURCE" ]
                        then
                          local __shellpen__append_main_sourceIndex=''
                          if ! shellpen -- getSourceIndex "$SHELLPEN_SOURCE" - __shellpen__append_main_sourceIndex
                          then
                            shellpen -- errors argumentError '%s\n%s' "Source '$1' does not exist" "Command: shellpen ${__shellpen__originalCliCommands[*]}"
                            return 1
                          else
                            _SHELLPEN_FUNCTION_OPEN[$__shellpen__append_main_sourceIndex]=true
                          fi
                        else
                          _SHELLPEN_FUNCTION_OPEN[$_SHELLPEN_CURRENT_SOURCE_INDEX]=true
                        fi
                      ## @
            
                          ;;
                      *)
                        echo "Unknown 'shellpen -- blocks functions' command: $__shellpen__mainCliCommands_command4" >&2
                        return 1
                        ;;
                    esac
              ## @
      
                  ;;
              *)
                echo "Unknown 'shellpen -- blocks' command: $__shellpen__mainCliCommands_command3" >&2
                return 1
                ;;
            esac
        ## @
  
            ;;
        "dump")
        ## @command shellpen -- dump
          ( set -o posix; set ) | grep SHELLPEN
        ## @
  
            ;;
        "errors")
        ## @command shellpen -- errors
            local __shellpen__mainCliCommandDepth="3"
            __shellpen__mainCliCommands+=("$1")
            local __shellpen__mainCliCommands_command3="$1"
            shift
            case "$__shellpen__mainCliCommands_command3" in
              "argumentError")
              ## @command shellpen -- errors argumentError
                if [ $# -gt 0 ]
                then
                  printf '`shellpen` [Argument Error] ' >&2
                  printf "$@" >&2
                else
                  printf '`shellpen` [Argument Error]' >&2
                fi
                shellpen -- errors printStackTrace
              ## @
      
                  ;;
              "getFileLine")
              ## @command shellpen -- errors getFileLine
                ## $1 Path to the file
                ## $2 Line to print
                ##
                if [ "$2" = "0" ]
                then
                  sed "1q;d" "$1" | sed 's/^ *//g'
                else
                  sed "${2}q;d" "$1" | sed 's/^ *//g'
                fi
              ## @
      
                  ;;
              "printStackTrace")
              ## @command shellpen -- errors printStackTrace
                ## $1 (_Optional_) How many levels to skip (default: `2`)
                ## $2 (_Optional_) How many levels deep to show (default: `100`)
                
                local __shellpen__x_errors_printStackTrace_levelsToSkip="${1-3}"
                local __shellpen__x_errors_printStackTrace_levelsToShow="${2-100}"
                
                if [ "$SHELLPEN_SILENCE" != "true" ]
                then
                  echo >&2
                  echo >&2
                  echo "Stacktrace:" >&2
                  echo >&2
                  local __shellpen__i=1
                  local __shellpen__stackIndex="$__shellpen__x_errors_printStackTrace_levelsToSkip"
                  while [ $__shellpen__stackIndex -lt ${#BASH_SOURCE[@]} ] && [ $__shellpen__i -lt $__shellpen__x_errors_printStackTrace_levelsToShow ]
                  do
                    local __shellpen__errors_printStackTrace_line=''
                    __shellpen__errors_printStackTrace_line="$( echo "$(shellpen -- errors getFileLine "${BASH_SOURCE[$__shellpen__stackIndex]}" "${BASH_LINENO[$(( __shellpen__stackIndex - 1 ))]}")" | sed 's/^/    /' 2>&1 )"
                    # Catches sed errors
                    if [ $? -eq 0 ]
                    then
                      echo "${BASH_SOURCE[$__shellpen__stackIndex]}:${BASH_LINENO[$(( __shellpen__stackIndex - 1 ))]} ${FUNCNAME[$__shellpen__stackIndex]}():" >&2
                      echo "  $__shellpen__errors_printStackTrace_line" >&2
                    else
                      echo "${BASH_SOURCE[$__shellpen__stackIndex]}:${BASH_LINENO[$(( __shellpen__stackIndex - 1 ))]} ${FUNCNAME[$__shellpen__stackIndex]}()" >&2
                    fi
                    echo >&2
                    : "$(( __shellpen__stackIndex++ ))"
                    : "$(( __shellpen__i++ ))"
                  done
                fi
              ## @
      
                  ;;
              *)
                echo "Unknown 'shellpen -- errors' command: $__shellpen__mainCliCommands_command3" >&2
                return 1
                ;;
            esac
        ## @
  
            ;;
        "getPenIndex")
        ## @command shellpen -- getPenIndex
          ## > Get the internal `shellpen` index of the provided pen
          ##
          ## ### Valid signatures:
          ##
          ## || Argument List | Description
          ## -|-
          ## `1` | `[pen]` | Print the index of the provided pen
          ## `3` | `[pen] [-] [varName]` | Get the index of the provided pen
          ##
          ## @return 1 If no pen with the given name exists (fails silently)
          ##
          
          if [ $# -eq 1 ]
          then
            local __shellpen__pens_exists_penIndex=''
            for __shellpen__pens_exists_penIndex in "${!_SHELLPEN_PENS[@]}"
            do
              if [ "$1" = "${_SHELLPEN_PENS[$__shellpen__pens_exists_penIndex]}" ]
              then
                printf '%s' "$__shellpen__pens_exists_penIndex" 
                return 0
              fi
            done
            return 1
          elif [ $# -eq 3 ] && [ "$2" = '-' ]
          then
            local __shellpen__pens_exists_penIndex=''
            for __shellpen__pens_exists_penIndex in "${!_SHELLPEN_PENS[@]}"
            do
              if [ "$1" = "${_SHELLPEN_PENS[$__shellpen__pens_exists_penIndex]}" ]
              then
                printf -v "$3" '%s' "$__shellpen__pens_exists_penIndex" 
                return 0
              fi
            done
            return 1
          else
            shellpen -- errors argumentError '%s\n%s' 'Invalid arguments' "Command: shellpen ${__shellpen__originalCliCommands[*]}"
            return 1
          fi
        ## @
  
            ;;
        "getSourceIndex")
        ## @command shellpen -- getSourceIndex
          ## > Get the internal `shellpen` index of the current or provided source
          ##
          ## ### Valid signatures:
          ##
          ## || Argument List | Description
          ## -|-
          ## `0` || Print the index of the current source
          ## `1` | `[source]` | Print the index of the provided source
          ## `2` | `[-] [varName]` | Get the index of the current source
          ## `3` | `[source] [-] [varName]` | Get the index of the provided source
          ##
          ## @return 1 If no source with the given name exists (fails silently)
          ##
          if [ $# -eq 0 ]
          then
            printf '%s' "$_SHELLPEN_CURRENT_SOURCE_INDEX"
          elif [ $# -eq 1 ]
          then
            local __shellpen__sources_exists_sourceIndex=''
            for __shellpen__sources_exists_sourceIndex in "${!_SHELLPEN_SOURCES[@]}"
            do
              if [ "$1" = "${_SHELLPEN_SOURCES[$__shellpen__sources_exists_sourceIndex]}" ]
              then
                printf '%s' "$__shellpen__sources_exists_sourceIndex" 
                return 0
              fi
            done
            return 1
          elif [ $# -eq 2 ] && [ "$1" = '-' ]
          then
            printf -v "$2" '%s' "$_SHELLPEN_CURRENT_SOURCE_INDEX" 
          elif [ $# -eq 3 ] && [ "$2" = '-' ]
          then
            local __shellpen__sources_exists_sourceIndex=''
            for __shellpen__sources_exists_sourceIndex in "${!_SHELLPEN_SOURCES[@]}"
            do
              if [ "$1" = "${_SHELLPEN_SOURCES[$__shellpen__sources_exists_sourceIndex]}" ]
              then
                printf -v "$3" '%s' "$__shellpen__sources_exists_sourceIndex" 
                return 0
              fi
            done
            return 1
          else
            shellpen -- errors argumentError '%s\n%s' 'Invalid arguments' "Command: shellpen ${__shellpen__originalCliCommands[*]}"
            return 1
          fi
        ## @
  
            ;;
        "log")
        ## @command shellpen -- log
          if [ "$SHELLPEN_VERBOSE" = true ]
          then
            echo "[shellpen] $*" >&2
          fi
        ## @
  
            ;;
        "writeMain")
        ## @command shellpen -- writeMain
          if [ -n "$SHELLPEN_SOURCE" ]
          then
            local __shellpen__append_append_sourceIndex=''
            if ! shellpen -- getSourceIndex "$SHELLPEN_SOURCE" - __shellpen__append_append_sourceIndex
            then
              shellpen -- errors argumentError '%s\n%s' "Source '$1' does not exist" "Command: shellpen ${__shellpen__originalCliCommands[*]}"
              return 1
            else
              if [ -n "${_SHELLPEN_MAIN_FUNCTION[$__shellpen__append_append_sourceIndex]}" ]
              then
                shellpen append writeln
                shellpen append writeln "[ \"\${BASH_SOURCE[0]}\" = \"\$0\" ] && \"${_SHELLPEN_MAIN_FUNCTION[$__shellpen__append_append_sourceIndex]}\" \"\$@\""
              fi
              _SHELLPEN_MAIN_FUNCTION[$__shellpen__append_append_sourceIndex]=""
              _SHELLPEN_SOURCECODE[$__shellpen__append_append_sourceIndex]+="$*"
            fi
          else
            if [ -n "${_SHELLPEN_MAIN_FUNCTION[$_SHELLPEN_CURRENT_SOURCE_INDEX]}" ]
            then
              shellpen append writeln
              shellpen append writeln "[ \"\${BASH_SOURCE[0]}\" = \"\$0\" ] && \"${_SHELLPEN_MAIN_FUNCTION[$_SHELLPEN_CURRENT_SOURCE_INDEX]}\" \"\$@\""
            fi
            _SHELLPEN_MAIN_FUNCTION[$_SHELLPEN_CURRENT_SOURCE_INDEX]=""
            _SHELLPEN_SOURCECODE[$_SHELLPEN_CURRENT_SOURCE_INDEX]+="$*"
          fi
        ## @
  
            ;;
        "writeShebang")
        ## @command shellpen -- writeShebang
          
          if [ -n "${_SHELLPEN_SHEBANG[$_SHELLPEN_CURRENT_SOURCE_INDEX]}" ]
          then
            _SHELLPEN_SOURCECODE[$_SHELLPEN_CURRENT_SOURCE_INDEX]="${_SHELLPEN_SHEBANG[$_SHELLPEN_CURRENT_SOURCE_INDEX]}\n${_SHELLPEN_SOURCECODE[$_SHELLPEN_CURRENT_SOURCE_INDEX]}"
          fi
          _SHELLPEN_SHEBANG[$_SHELLPEN_CURRENT_SOURCE_INDEX]=""
        ## @
  
            ;;
        *)
          echo "Unknown 'shellpen --' command: $__shellpen__mainCliCommands_command2" >&2
          return 1
          ;;
      esac
    ## @

        ;;
    "append")
    ## @command shellpen append
      local __shellpen__mainCliCommandDepth="2"
      __shellpen__mainCliCommands+=("$1")
      local __shellpen__mainCliCommands_command2="$1"
      shift
      case "$__shellpen__mainCliCommands_command2" in
        "appendln")
        ## @command shellpen append appendln
          shellpen -- log appendln "$@"
          local __shellpen__append_appendln_newLine=$'\n'
          if [ -n "$SHELLPEN_SOURCE" ]
          then
            local __shellpen__append_appendln_sourceIndex=''
            if ! shellpen -- getSourceIndex "$SHELLPEN_SOURCE" - __shellpen__append_appendln_sourceIndex
            then
              shellpen -- errors argumentError '%s\n%s' "Source '$1' does not exist" "Command: shellpen ${__shellpen__originalCliCommands[*]}"
              return 1
            else
              _SHELLPEN_SOURCECODE[$__shellpen__append_appendln_sourceIndex]+="$*${__shellpen__append_appendln_newLine}"
            fi
          else
            _SHELLPEN_SOURCECODE[$_SHELLPEN_CURRENT_SOURCE_INDEX]+="$*${__shellpen__append_appendln_newLine}"
          fi
        ## @
  
            ;;
        "append")
        ## @command shellpen append append
          shellpen -- log append "$@"
          if [ -n "$SHELLPEN_SOURCE" ]
          then
            local __shellpen__append_append_sourceIndex=''
            if ! shellpen -- getSourceIndex "$SHELLPEN_SOURCE" - __shellpen__append_append_sourceIndex
            then
              shellpen -- errors argumentError '%s\n%s' "Source '$1' does not exist" "Command: shellpen ${__shellpen__originalCliCommands[*]}"
              return 1
            else
              _SHELLPEN_SOURCECODE[$__shellpen__append_append_sourceIndex]+="$*"
            fi
          else
            _SHELLPEN_SOURCECODE[$_SHELLPEN_CURRENT_SOURCE_INDEX]+="$*"
          fi
        ## @
  
            ;;
        "array")
        ## @command shellpen append array
          if [ $# -eq 1 ]
          then
            if [[ "$1" =~ ^[^=]+=[^=]+$ ]]
            then
              shellpen append writeln "declare -a ${1%%=*}=(\"${1#*=}\")"
            else
              shellpen append writeln "declare -a $*"
            fi
          elif [ $# -eq 2 ]
          then
            shellpen append writeln "declare -a $1=(\"$2\")"
          fi
        ## @
  
            ;;
        "break")
        ## @command shellpen append break
          shellpen append writeln "break"
        ## @
  
            ;;
        "case")
        ## @command shellpen append case
          shellpen append writeln "case \"$1\" in"
          shellpen append indent++
        ## @
  
            ;;
        "code")
        ## @command shellpen append code
          shellpen append result "$@"
        ## @
  
            ;;
        "comment")
        ## @command shellpen append comment
          ## $1 foo
          ## $@ stuff
          ##
          ## Some stuff about the comment
          ##
          ## Here come some params:
          ##
          ##
          ## Hello
          ##
          
          shellpen append writeln "# $*"
        ## @
  
            ;;
        "done")
        ## @command shellpen append done
          shellpen append indent--
          shellpen append writeln "done"
        ## @
  
            ;;
        "echo")
        ## @command shellpen append echo
          shellpen append writeln "echo \"$*\""
        ## @
  
            ;;
        "else")
        ## @command shellpen append else
          shellpen append indent--
          shellpen append writeln "else"
          shellpen append indent++
        ## @
  
            ;;
        "error")
        ## @command shellpen append error
          # TODO get return code if provided!
          
          if [ $# -eq 0 ]
          then
            shellpen append writeln echo '>&2'
            shellpen append return 1
          elif [ $# -eq 1 ]
          then
            shellpen append writeln echo \"$*\" '>&2'
            shellpen append return 1
          else
            shellpen append writeln printf $@ '>&2'
            shellpen append return 1
          fi
        ## @
  
            ;;
        "esac")
        ## @command shellpen append esac
          _SHELLPEN_CASE_OPEN[$_SHELLPEN_CURRENT_SOURCE_INDEX]=false
          # Close existing option, if open
          shellpen append indent--
          shellpen append writeln "esac"
        ## @
  
            ;;
        "fi")
        ## @command shellpen append fi
          shellpen append indent--
          shellpen append writeln "fi"
        ## @
  
            ;;
        "fn")
        ## @command shellpen append fn
          shellpen function "$@"
        ## @
  
            ;;
        "for")
        ## @command shellpen append for
          shellpen append writeln "for $*"
          shellpen append writeln "do"
          shellpen append indent++
        ## @
  
            ;;
        "function")
        ## @command shellpen append function
          shellpen append writeln
          shellpen append writeln "${1%()}() {"
          shellpen append indent++
          shellpen -- blocks functions open
        ## @
  
            ;;
        "hash")
        ## @command shellpen append hash
          if [ $# -eq 1 ]
          then
            if [[ "$1" =~ ^[^=]+=[^=]+$ ]]
            then
              shellpen append writeln "declare -A ${1%%=*}=(\"${1#*=}\")"
            else
              shellpen append writeln "declare -A $*"
            fi
          elif [ $# -eq 2 ]
          then
            shellpen append writeln "declare -A $1=(\"$2\")"
          fi
        ## @
  
            ;;
        "if")
        ## @command shellpen append if
          local __shellpen__if_source="${*/AND/&&}"
          shellpen append writeln "if ${__shellpen__if_source/OR/||}"
          shellpen append writeln "then"
          shellpen append indent++
        ## @
  
            ;;
        "indentation")
        ## @command shellpen append indentation
          local __shellpen__indentation=""
          local __shellpen__indentationLevel=0
          
          if [ -n "$SHELLPEN_SOURCE" ]
          then
            local __shellpen__append_indentation_sourceIndex=''
            if ! shellpen -- getSourceIndex "$SHELLPEN_SOURCE" - __shellpen__append_indentation_sourceIndex
            then
              shellpen -- errors argumentError '%s\n%s' "Source '$1' does not exist" "Command: shellpen ${__shellpen__originalCliCommands[*]}"
              return 1
            else
              while [ $__shellpen__indentationLevel -lt "${_SHELLPEN_INDENT_LEVELS[$__shellpen__append_indentation_sourceIndex]}" ]
              do
                __shellpen__indentation+="$SHELLPEN_INDENT"
                : "$(( __shellpen__indentationLevel++ ))"
              done
            fi
          else
            while [ $__shellpen__indentationLevel -lt "${_SHELLPEN_INDENT_LEVELS[$_SHELLPEN_CURRENT_SOURCE_INDEX]}" ]
            do
              __shellpen__indentation+="$SHELLPEN_INDENT"
              : "$(( __shellpen__indentationLevel++ ))"
            done
          fi
          
          printf "$__shellpen__indentation"
        ## @
  
            ;;
        "indent++")
        ## @command shellpen append indent++
          if [ -n "$SHELLPEN_SOURCE" ]
          then
            local __shellpen__append_indentPlus_sourceIndex=''
            if ! shellpen -- getSourceIndex "$SHELLPEN_SOURCE" - __shellpen__append_indentPlus_sourceIndex
            then
              shellpen -- errors argumentError '%s\n%s' "Source '$1' does not exist" "Command: shellpen ${__shellpen__originalCliCommands[*]}"
              return 1
            else
              _SHELLPEN_INDENT_LEVELS[$__shellpen__append_indentPlus_sourceIndex]="$(( ${_SHELLPEN_INDENT_LEVELS[$__shellpen__append_indentPlus_sourceIndex]} + 1 ))"
            fi
          else
            _SHELLPEN_INDENT_LEVELS[$_SHELLPEN_CURRENT_SOURCE_INDEX]="$(( ${_SHELLPEN_INDENT_LEVELS[$_SHELLPEN_CURRENT_SOURCE_INDEX]} + 1 ))"
          fi
        ## @
  
            ;;
        "indent--")
        ## @command shellpen append indent--
          if [ -n "$SHELLPEN_SOURCE" ]
          then
            local __shellpen__append_indentMinus_sourceIndex=''
            if ! shellpen -- getSourceIndex "$SHELLPEN_SOURCE" - __shellpen__append_indentMinus_sourceIndex
            then
              shellpen -- errors argumentError '%s\n%s' "Source '$1' does not exist" "Command: shellpen ${__shellpen__originalCliCommands[*]}"
              return 1
            else
              _SHELLPEN_INDENT_LEVELS[$__shellpen__append_indentMinus_sourceIndex]="$(( ${_SHELLPEN_INDENT_LEVELS[$__shellpen__append_indentMinus_sourceIndex]} - 1 ))"
            fi
          else
            _SHELLPEN_INDENT_LEVELS[$_SHELLPEN_CURRENT_SOURCE_INDEX]="$(( ${_SHELLPEN_INDENT_LEVELS[$_SHELLPEN_CURRENT_SOURCE_INDEX]} - 1 ))"
          fi
        ## @
  
            ;;
        "int")
        ## @command shellpen append int
          if [ $# -eq 1 ]
          then
            if [[ "$1" =~ ^[^=]+=[^=]+$ ]]
            then
              shellpen append writeln "declare -i ${1%%=*}=${1#*=}"
            else
              shellpen append writeln "declare -i $*"
            fi
          elif [ $# -eq 2 ]
          then
            shellpen append writeln "declare -i $1=$2"
          fi
        ## @
  
            ;;
        "local")
        ## @command shellpen append local
          if [ $# -eq 1 ]
          then
            if [[ "$1" =~ ^[^=]+=[^=]+$ ]]
            then
              shellpen append writeln "local ${1%%=*}=\"${1#*=}\""
            else
              shellpen append writeln "local $*"
            fi
          elif [ $# -eq 2 ]
          then
            shellpen append writeln "local $1=\"$2\""
          fi
        ## @
  
            ;;
        "main")
        ## @command shellpen append main
          if [ -n "$SHELLPEN_SOURCE" ]
          then
            local __shellpen__append_main_sourceIndex=''
            if ! shellpen -- getSourceIndex "$SHELLPEN_SOURCE" - __shellpen__append_main_sourceIndex
            then
              shellpen -- errors argumentError '%s\n%s' "Source '$1' does not exist" "Command: shellpen ${__shellpen__originalCliCommands[*]}"
              return 1
            else
              _SHELLPEN_MAIN_FUNCTION[$__shellpen__append_main_sourceIndex]="$1"
            fi
          else
            _SHELLPEN_MAIN_FUNCTION[$_SHELLPEN_CURRENT_SOURCE_INDEX]="$1"
          fi
        ## @
  
            ;;
        "map")
        ## @command shellpen append map
          shellpen append hash "$@"
        ## @
  
            ;;
        "option")
        ## @command shellpen append option
          shellpen append writeln "$1)"
          shellpen append indent++
        ## @
  
            ;;
        "preview")
        ## @command shellpen append preview
          shellpen append result "$@"
        ## @
  
            ;;
        "putAway")
        ## @command shellpen append putAway
          # local __shellpen__append_appendln_newLine=$'\n'
          
          if [ -n "$SHELLPEN_PEN" ]
          then
            shellpen pens putAway "$SHELLPEN_PEN" "$@"
          else
            shellpen -- errors argumentError '%s\n%s' "\`append putAway\` can only be called by a Pen, try \`shellpen pens putAway [name]\` instead" "Command: shellpen ${__shellpen__originalCliCommands[*]}"
            return 1
          fi
        ## @
  
            ;;
        "result")
        ## @command shellpen append result
          shellpen -- blocks closeAll
          shellpen -- writeMain
          
          if [ -n "$SHELLPEN_SOURCE" ]
          then
            local __shellpen__append_write_sourceIndex=''
            if ! shellpen -- getSourceIndex "$SHELLPEN_SOURCE" - __shellpen__append_write_sourceIndex
            then
              shellpen -- errors argumentError '%s\n%s' "Source '$1' does not exist" "Command: shellpen ${__shellpen__originalCliCommands[*]}"
              return 1
            else
              if [ "$1" = "-n" ]
              then
                echo -e "${_SHELLPEN_SOURCECODE[$__shellpen__append_write_sourceIndex]}" | cat -n
              else
                echo -e "${_SHELLPEN_SOURCECODE[$__shellpen__append_write_sourceIndex]}"
              fi
            fi
          else
            if [ "$1" = "-n" ]
            then
              echo -e "${_SHELLPEN_SOURCECODE[$_SHELLPEN_CURRENT_SOURCE_INDEX]}" | cat -n
            else
              echo -e "${_SHELLPEN_SOURCECODE[$_SHELLPEN_CURRENT_SOURCE_INDEX]}"
            fi
          fi
        ## @
  
            ;;
        "return")
        ## @command shellpen append return
          if [ $# -eq 1 ]
          then
            shellpen append writeln "return $1"
          else
            shellpen append writeln "return 1"
          fi
        ## @
  
            ;;
        "save")
        ## @command shellpen append save
          shellpen result > "$1"
          chmod +x "$1"
        ## @
  
            ;;
        "++")
        ## @command shellpen append ++
          shellpen append writeln "(( $1++ ))"
        ## @
  
            ;;
        "--")
        ## @command shellpen append --
          shellpen append writeln "(( $1-- ))"
        ## @
  
            ;;
        ":")
        ## @command shellpen append :
          shellpen append writeln ":"
        ## @
  
            ;;
        "::")
        ## @command shellpen append ::
          shellpen append writeln ";;"
          shellpen append indent--
        ## @
  
            ;;
        "}")
        ## @command shellpen append }
          shellpen append indent--
          shellpen append writeln "}"
          
          if [ -n "$SHELLPEN_SOURCE" ]
          then
            local __shellpen__append_main_sourceIndex=''
            if ! shellpen -- getSourceIndex "$SHELLPEN_SOURCE" - __shellpen__append_main_sourceIndex
            then
              shellpen -- errors argumentError '%s\n%s' "Source '$1' does not exist" "Command: shellpen ${__shellpen__originalCliCommands[*]}"
              return 1
            else
              _SHELLPEN_FUNCTION_OPEN[$__shellpen__append_main_sourceIndex]=false
            fi
          else
            _SHELLPEN_FUNCTION_OPEN[$_SHELLPEN_CURRENT_SOURCE_INDEX]=false
          fi
        ## @
  
            ;;
        "shebang")
        ## @command shellpen append shebang
          _SHELLPEN_SHEBANG[$_SHELLPEN_CURRENT_SOURCE_INDEX]="$*"
        ## @
  
            ;;
        "shift")
        ## @command shellpen append shift
          shellpen append writeln shift
        ## @
  
            ;;
        "stderr")
        ## @command shellpen append stderr
          if [ $# -eq 0 ]
          then
            shellpen append writeln echo '>&2'
          elif [ $# -eq 1 ]
          then
            shellpen append writeln echo \"$*\" '>&2'
          else
            shellpen append writeln printf $@ '>&2'
          fi
        ## @
  
            ;;
        "switchTo")
        ## @command shellpen append switchTo
          ## > Switch pen to write to a different source
          ##
          ## $1 Name of the source to switch to
          ##
          ## @return 1 If the provided source does not exist
          ##
          
          if [ $# -eq 1 ]
          then
            if [ -z "$SHELLPEN_PEN" ]
            then
              shellpen -- errors argumentError '%s\n%s' "Please do not call 'append switchTo' directly, call it via a pen function (this function requires setting \$SHELLPEN_PEN=\"[pen name]\" which is done automatically when using a pen function)" "Command: shellpen ${__shellpen__originalCliCommands[*]}"
              return 1
            fi
            if shellpen sources exists "$1"
            then
              local __shellpen__append_switchTo_penIndex=''
              shellpen -- getPenIndex "$SHELLPEN_PEN" - __shellpen__append_switchTo_penIndex
              _SHELLPEN_PEN_SOURCES["$__shellpen__append_switchTo_penIndex"]="$1"
            else
              shellpen -- errors argumentError '%s\n%s' "Source '$1' does not exist" "Command: shellpen ${__shellpen__originalCliCommands[*]}"
              return 1
            fi
          else
            shellpen -- errors argumentError '%s\n%s' 'Invalid arguments' "Command: shellpen ${__shellpen__originalCliCommands[*]}"
            return 1
          fi
        ## @
  
            ;;
        "while")
        ## @command shellpen append while
          local __shellpen__while_source="${*/AND/&&}"
          shellpen append writeln "while ${__shellpen__while_source/OR/||}"
          shellpen append writeln "do"
          shellpen append indent++
        ## @
  
            ;;
        "writeFile")
        ## @command shellpen append writeFile
          if ! [ -f "$1" ]
          then
            shellpen -- errors argumentError '%s\n%s' "File '$1' does not exist" "Command: shellpen ${__shellpen__originalCliCommands[*]}"
            return 1
          fi
          
          if [ -n "$SHELLPEN_SOURCE" ]
          then
            local __shellpen__append_writeFile_newLine=$'\n'
            local __shellpen__append_writeFile_sourceIndex=''
            if ! shellpen -- getSourceIndex "$SHELLPEN_SOURCE" - __shellpen__append_writeFile_sourceIndex
            then
              shellpen -- errors argumentError '%s\n%s' "Source '$1' does not exist" "Command: shellpen ${__shellpen__originalCliCommands[*]}"
              return 1
            else
              _SHELLPEN_SOURCECODE[$__shellpen__append_writeFile_sourceIndex]+="$( cat "$1" | sed "s/^/$( shellpen indentation )/" )${__shellpen__append_writeFile_newLine}"
            fi
          else
              _SHELLPEN_SOURCECODE[$_SHELLPEN_CURRENT_SOURCE_INDEX]+="$( cat "$1" | sed "s/^/$( shellpen indentation )/" )${__shellpen__append_writeFile_newLine}"
          fi
        ## @
  
            ;;
        "writeln")
        ## @command shellpen append writeln
          shellpen -- log writeln "$@"
          local __shellpen__append_writeln_newLine=$'\n'
          if [ -n "$SHELLPEN_SOURCE" ]
          then
            local __shellpen__append_writeln_sourceIndex=''
            if ! shellpen -- getSourceIndex "$SHELLPEN_SOURCE" - __shellpen__append_writeln_sourceIndex
            then
              shellpen -- errors argumentError '%s\n%s' "Source '$1' does not exist" "Command: shellpen ${__shellpen__originalCliCommands[*]}"
              return 1
            else
              _SHELLPEN_SOURCECODE[$__shellpen__append_writeln_sourceIndex]+="$( shellpen append indentation )$*${__shellpen__append_writeln_newLine}"
            fi
          else
            _SHELLPEN_SOURCECODE[$_SHELLPEN_CURRENT_SOURCE_INDEX]+="$( shellpen append indentation )$*${__shellpen__append_writeln_newLine}"
          fi
        ## @
  
            ;;
        "write")
        ## @command shellpen append write
          shellpen -- log write "$@"
          if [ -n "$SHELLPEN_SOURCE" ]
          then
            local __shellpen__append_write_sourceIndex=''
            if ! shellpen -- getSourceIndex "$SHELLPEN_SOURCE" - __shellpen__append_write_sourceIndex
            then
              shellpen -- errors argumentError '%s\n%s' "Source '$1' does not exist" "Command: shellpen ${__shellpen__originalCliCommands[*]}"
              return 1
            else
              _SHELLPEN_SOURCECODE[$__shellpen__append_write_sourceIndex]+="$( shellpen indentation )$*"
            fi
          else
            _SHELLPEN_SOURCECODE[$_SHELLPEN_CURRENT_SOURCE_INDEX]+="$( shellpen indentation )$*"
          fi
        ## @
  
            ;;
        *)
          echo "# ARGS to append $# '$*'"
          ;;
      esac
    ## @

        ;;
    "code")
    ## @command shellpen code
      shellpen result "$@"
    ## @

        ;;
    "indentation")
    ## @command shellpen indentation
      local __shellpen__indentation=""
      local __shellpen__indentationLevel=0
      while [ $__shellpen__indentationLevel -lt "${_SHELLPEN_INDENT_LEVELS[$_SHELLPEN_CURRENT_SOURCE_INDEX]}" ]
      do
        __shellpen__indentation+="$SHELLPEN_INDENT"
        : "$(( __shellpen__indentationLevel++ ))"
      done
      printf "$__shellpen__indentation"
    ## @

        ;;
    "pens")
    ## @command shellpen pens
      local __shellpen__mainCliCommandDepth="2"
      __shellpen__mainCliCommands+=("$1")
      local __shellpen__mainCliCommands_command2="$1"
      shift
      case "$__shellpen__mainCliCommands_command2" in
        "exists")
        ## @command shellpen pens exists
          shellpen -- getPenIndex "$@" >/dev/null
        ## @
  
            ;;
        "getSource")
        ## @command shellpen pens getSource
          ## > Print or get the name of the source associated with the given pen name
          ##
          ## ### Valid signatures:
          ##
          ## || Argument List | Description
          ## -|-
          ## `1` | `[name]` | Print the source name associated with the provided pen name
          ## `3` | `[name] [-] [varName]` | Get the source name associated with the provided pen name
          ##
          ## @return 1 If no pen with the given name exists
          
          if [ $# -gt 0 ] && ! shellpen pens exists "$1"
          then
            shellpen -- errors argumentError '%s\n%s' "Pen not found: '$1'" "Command: shellpen ${__shellpen__originalCliCommands[*]}"
            return 1
          fi
          
          if [ $# -eq 1 ]
          then
            local __shellpen__pens_getSource_penIndex=''
            shellpen -- getPenIndex "$1" - __shellpen__pens_getSource_penIndex
            printf '%s' "${_SHELLPEN_PEN_SOURCES["$__shellpen__pens_getSource_penIndex"]}"
          elif [ $# -eq 3 ] && [ "$2" = '-' ]
          then
            local __shellpen__pens_getSource_penIndex=''
            shellpen -- getPenIndex "$1" - __shellpen__pens_getSource_penIndex
            printf -v "$3" '%s' "${_SHELLPEN_PEN_SOURCES["$__shellpen__pens_getSource_penIndex"]}"
          else
            shellpen -- errors argumentError '%s\n%s' 'Invalid arguments' "Command: shellpen ${__shellpen__originalCliCommands[*]}"
            return 1
          fi
        ## @
  
            ;;
        "list")
        ## @command shellpen pens list
          local __shellpen__pens_list_sourceName=''
          [ $# -eq 2 ] && [ "$1" = "-" ] && eval "$2=()"
          for __shellpen__pens_list_sourceName in "${_SHELLPEN_PENS[@]}"
          do
            if [ $# -eq 2 ] && [ "$1" = "-" ]
            then
              eval "$2+=(\"\$__shellpen__pens_list_sourceName\")"
            else
              echo "$__shellpen__pens_list_sourceName"
            fi
          done
        ## @
  
            ;;
        "new")
        ## @command shellpen pens new
          ## > Create a new pen (optionally associated with a new or existing source)
          ##
          ## ### Valid signatures:
          ##
          ## || Argument List | Description
          ## -|-
          ## `1` | `[name]` | Create a new pen for the current source with the provided name
          ## `2` | `[name] [source]` | Create a new pen for the provided source (will be created if it does not already exist)
          ## `2` | `[name] [-]` | Create a new pen for the current source _but do not create a writer alias function_
          ## `3` | `[name] [-] [alias]` | Create a new pen for the current source _and create an alias function with the provided name_
          ## `3` | `[name] [source] [-]` | Create a new pen for the provided source (will be created if it does not already exist) _but do not create a writer alias function_
          ## `4` | `[name] [source] [-] [alias]` | Create a new pen for the provided source (will be created if it does not already exist) _and create an alias function with the provided name_
          ##
          ## @return 1 Pen with the existing name already exists
          ##
          ## #### Aliases
          ##
          ## Regardless of the alias you provide, `shellpen` will create a BASH function with the provided name.
          ##
          ## It is up to you to provide a valid function name! If the function name is invalid, this will fail.
          ##
          ## This also allows you to accidentally create pens with names which override built-in BASH functions
          ## such as 'unset' or 'declare' which will essentially completely blow up the world 💥
          
          local __shellpen__pens_new_penName=''
          local __shellpen__pens_new_sourceName=''
          local __shellpen__pens_new_createAlias=true
          local __shellpen__pens_new_aliasName=''
          
          if [ $# -eq 1 ]
          then
            __shellpen__pens_new_penName="$1"
          elif [ $# -eq 2 ] && [ "$2" = '-' ]
          then
            __shellpen__pens_new_penName="$1"
            __shellpen__pens_new_createalias=false
          elif [ $# -eq 2 ]
          then
            __shellpen__pens_new_penName="$1"
            __shellpen__pens_new_sourceName="$2"
          elif [ $# -eq 3 ] && [ "$2" = '-' ]
          then
            __shellpen__pens_new_penName="$1"
            __shellpen__pens_new_aliasName="$3"
          elif [ $# -eq 3 ] && [ "$3" = '-' ]
          then
            __shellpen__pens_new_penName="$1"
            __shellpen__pens_new_sourceName="$2"
            __shellpen__pens_new_createalias=false
          elif [ $# -eq 4 ] && [ "$3" = '-' ]
          then
            __shellpen__pens_new_penName="$1"
            __shellpen__pens_new_sourceName="$2"
            __shellpen__pens_new_aliasName="$4"
          else
            shellpen -- errors argumentError '%s\n%s' 'Invalid arguments' "Command: shellpen ${__shellpen__originalCliCommands[*]}"
            return 1
          fi
          
          if shellpen pens exists "$__shellpen__pens_new_penName"
          then
            shellpen -- errors argumentError '%s\n%s' "Pen '$__shellpen__pens_new_penName' already exists" "Command: shellpen ${__shellpen__originalCliCommands[*]}"
            return 1
          fi
          
          # DO NOT ADD EXTRA DEFAULTS - BAIL
          if [ "$__shellpen__pens_new_penName" = default ]
          then
            shellpen -- errors argumentError '%s\n%s' "Pen 'default' already exists" "Command: shellpen ${__shellpen__originalCliCommands[*]}"
            return 1
          fi
          
          if [ -n "$__shellpen__pens_new_sourceName" ] && ! shellpen sources exists "$__shellpen__pens_new_sourceName"
          then
            shellpen sources new "$__shellpen__pens_new_sourceName"
          fi
          
          [ -z "$__shellpen__pens_new_sourceName" ] && shellpen sources current __shellpen__pens_new_sourceName
          
          if [ "$__shellpen__pens_new_createAlias" = true ]
          then
            [ -z "$__shellpen__pens_new_aliasName" ] && __shellpen__pens_new_aliasName="$__shellpen__pens_new_penName"
            local __shellpen__pens_new_aliasFunctionCode="
          $__shellpen__pens_new_aliasName() {
            # Get the source name for this pen
            local __shellpen__penAlias_sourceName=''
            shellpen pens getSource \"$__shellpen__pens_new_penName\" - __shellpen__penAlias_sourceName
          
            # Call an 'append' shellpen DSL function
            # Sets the SHELLPEN_SOURCE environment variable which 'append' functions respect
            # to the *current* source for this pen (allowing the source to be changed later)
            # Also provides the pen name for debugging.
            SHELLPEN_SOURCE=\"\$__shellpen__penAlias_sourceName\" SHELLPEN_PEN=\"$__shellpen__pens_new_penName\" shellpen append \"\$@\"
          }
          "
            # Try it in a subshell first
            local __shellpen__pens_new_aliasFunctionEvalOutput=''
            __shellpen__pens_new_aliasFunctionEvalOutput="$( eval "$__shellpen__pens_new_aliasFunctionCode" 2>&1 )"
            if [ $? -ne 0 ]
            then
              shellpen -- errors argumentError '%s\n%s\n%s' "Alias name '$__shellpen__pens_new_aliasName' is not valid, please choose something that works as as valid BASH function name. Pen creation failed." "Command: shellpen ${__shellpen__originalCliCommands[*]}" "Function creation error: '$__shellpen__pens_new_aliasFunctionEvalOutput'"
              return 2
            else
              eval "$__shellpen__pens_new_aliasFunctionCode"
            fi
          fi
          
          
          _SHELLPEN_PENS+=("$__shellpen__pens_new_penName")
          _SHELLPEN_PEN_SOURCES+=("$__shellpen__pens_new_sourceName")
        ## @
  
            ;;
        "putAway")
        ## @command shellpen pens putAway
          ## > Put away this pen (delete it) and optionally the source too (if `withSource` provided)
          ##
          ## ### Valid signatures:
          ##
          ## || Argument List | Description
          ## -|-
          ## `1` | `[pen]` | Name of the pen to put away (or default)
          ## `2` | `withSource` | Optional
          ##
          ## @return 1 If the provided pen name does not exist
          ## @return 2 If the provided source name does not exist
          ##
          
          local __shellpen__pens_putAway_penName=default
          local __shellpen__pens_putAway_withSource=false
          if [ "$1" = "withSource" ]
          then
            __shellpen__pens_putAway_withSource=true
            shift
          elif [ "$2" = "withSource" ]
          then
            __shellpen__pens_putAway_penName="$1"
            __shellpen__pens_putAway_withSource=true
          elif [ $# -eq 1 ]
          then
            __shellpen__pens_putAway_penName="$1"
          fi
          
          local __shellpen__pens_putAway_penIndex=''
          if ! shellpen -- getPenIndex "$__shellpen__pens_putAway_penName" - __shellpen__pens_putAway_penIndex
          then
            shellpen -- errors argumentError '%s\n%s' "Pen not found: '$__shellpen__pens_putAway_penName'" "Command: shellpen ${__shellpen__originalCliCommands[*]}"
            return 1
          else
            if [ "$__shellpen__pens_putAway_withSource" = true ]
            then
              local __shellpen__pens_putAway_sourceName=''
              shellpen pens getSource "$__shellpen__pens_putAway_penName" - __shellpen__pens_putAway_sourceName
              shellpen sources putAway "$__shellpen__pens_putAway_sourceName" || return %?
            fi
            unset "_SHELLPEN_PENS[$__shellpen__pens_putAway_penIndex]"
            unset "_SHELLPEN_PEN_SOURCES[$__shellpen__pens_putAway_penIndex]"
            if [ "$_SHELLPEN_CURRENT_PEN_NAME" = "$__shellpen__pens_putAway_penName" ]
            then
              _SHELLPEN_CURRENT_PEN_NAME=default
              _SHELLPEN_CURRENT_PEN_INDEX=0
            fi
            _SHELLPEN_PENS=("${_SHELLPEN_PENS[@]}")
            _SHELLPEN_PEN_SOURCES=("${_SHELLPEN_PEN_SOURECS[@]}")
          fi
        ## @
  
            ;;
        "switchSource")
        ## @command shellpen pens switchSource
          ## > Switch the current or provided pen to use a different, provided source
          ##
          ## ### Valid signatures:
          ##
          ## || Argument List | Description
          ## -|-
          ## `1` | `[source]` | Set the default pen's source to use the provided source
          ## `2` | `[pen] [source]` | Set the provided pen to use the provided source
          ##
          ## @return 1 If the provided pen name does not exist
          ## @return 2 If the provided source name does not exist
          ##
          
          if [ $# -eq 1 ]
          then
            # "default" should be '0' but it could be deleted (once we provide that functionality)
            local __shellpen__pens_switchSource_penIndex=''
            if ! shellpen -- getPenIndex "default" - __shellpen__pens_switchSource_penIndex
            then
              shellpen -- errors argumentError '%s\n%s' "Pen not found: 'default'" "Command: shellpen ${__shellpen__originalCliCommands[*]}"
              return 1
            else
              if shellpen sources exists "$1"
              then
                _SHELLPEN_PEN_SOURCES["$__shellpen__pens_switchSource_penIndex"]="$1"
              else
                shellpen -- errors argumentError '%s\n%s' "Source '$1' does not exist" "Command: shellpen ${__shellpen__originalCliCommands[*]}"
                return 2
              fi
            fi
          elif [ $# -eq 2 ]
          then
            local __shellpen__pens_switchSource_penIndex=''
            if ! shellpen -- getPenIndex "$1" - __shellpen__pens_switchSource_penIndex
            then
              shellpen -- errors argumentError '%s\n%s' "Pen not found: '$1'" "Command: shellpen ${__shellpen__originalCliCommands[*]}"
              return 1
            else
              if shellpen sources exists "$2"
              then
                _SHELLPEN_PEN_SOURCES["$__shellpen__pens_switchSource_penIndex"]="$2"
              else
                shellpen -- errors argumentError '%s\n%s' "Source '$2' does not exist" "Command: shellpen ${__shellpen__originalCliCommands[*]}"
                return 2
              fi
            fi
          fi
        ## @
  
            ;;
        *)
          echo "Unknown 'shellpen pens' command: $__shellpen__mainCliCommands_command2" >&2
          return 1
          ;;
      esac
    ## @

        ;;
    "pen")
    ## @command shellpen pen
      shellpen pens new "$@"
    ## @

        ;;
    "preview")
    ## @command shellpen preview
      shellpen result "$@"
    ## @

        ;;
    "result")
    ## @command shellpen result
      shellpen -- blocks closeAll
      shellpen -- writeMain
      
      if [ "$1" = "-n" ]
      then
        echo -e "${_SHELLPEN_SOURCECODE[$_SHELLPEN_CURRENT_SOURCE_INDEX]}" | cat -n
      else
        echo -e "${_SHELLPEN_SOURCECODE[$_SHELLPEN_CURRENT_SOURCE_INDEX]}"
      fi
    ## @

        ;;
    "-")
    ## @command shellpen -
      shellpen pen -
    ## @

        ;;
    "_")
    ## @command shellpen _
      shellpen pen _
    ## @

        ;;
    "sources")
    ## @command shellpen sources
    ## > Something about sources
    ##
    ## And more here too
      local __shellpen__mainCliCommandDepth="2"
      __shellpen__mainCliCommands+=("$1")
      local __shellpen__mainCliCommands_command2="$1"
      shift
      case "$__shellpen__mainCliCommands_command2" in
        "current")
        ## @command shellpen sources current
          if [ -n "$1" ]
          then
            printf -v "$1" '%s' "${_SHELLPEN_SOURCES[$_SHELLPEN_CURRENT_SOURCE_INDEX]}"
          else
            printf '%s' "${_SHELLPEN_SOURCES[$_SHELLPEN_CURRENT_SOURCE_INDEX]}"
          fi
        ## @
  
            ;;
        "exists")
        ## @command shellpen sources exists
          shellpen -- getSourceIndex "$@" >/dev/null
        ## @
  
            ;;
        "getFilePath")
        ## @command shellpen sources getFilePath
          ## > Print or get the file path of the current or provided source
          ##
          ## ### Valid signatures:
          ##
          ## || Argument List | Description
          ## -|-
          ## `0` || Print the file path of the current source
          ## `1` | `[name]` | Print the file path of the provided source
          ## `2` | `[-] [varName]` | Get the file path of the current source
          ## `3` | `[name] [-] [varName]` | Get the file path of the provided source
          ##
          ## @return 1 If source provided but source does not exist (fails silently)
          ## @return 2 If source does not have a file path configured (fails silently)
          
          local __shellpen__sources_getFilePath_sourceIndex=''
          
          if [ $# -eq 0 ]
          then
            shellpen -- getSourceIndex - __shellpen__sources_getFilePath_sourceIndex
            local __shellpen__sources_getFilePath_sourceFilePath="${_SHELLPEN_SOURCES_FILE_PATHS["$__shellpen__sources_getFilePath_sourceIndex"]}"
            [ -z "$__shellpen__sources_getFilePath_sourceFilePath" ] && return 2
            printf '%s' "$__shellpen__sources_getFilePath_sourceFilePath"
          elif [ $# -eq 1 ]
          then
            shellpen -- getSourceIndex "$1" - __shellpen__sources_getFilePath_sourceIndex || return 1
            local __shellpen__sources_getFilePath_sourceFilePath="${_SHELLPEN_SOURCES_FILE_PATHS["$__shellpen__sources_getFilePath_sourceIndex"]}"
            [ -z "$__shellpen__sources_getFilePath_sourceFilePath" ] && return 2
            printf '%s' "$__shellpen__sources_getFilePath_sourceFilePath"
          elif [ $# -eq 2 ]
          then
            if [ "$1" = '-' ]
            then
              shellpen -- getSourceIndex - __shellpen__sources_getFilePath_sourceIndex
              local __shellpen__sources_getFilePath_sourceFilePath="${_SHELLPEN_SOURCES_FILE_PATHS["$__shellpen__sources_getFilePath_sourceIndex"]}"
              [ -z "$__shellpen__sources_getFilePath_sourceFilePath" ] && return 2
              printf -v "$2" '%s' "$__shellpen__sources_getFilePath_sourceFilePath"
            else
              shellpen -- errors argumentError '%s\n%s' 'Invalid arguments' "Command: shellpen ${__shellpen__originalCliCommands[*]}"
              return 1
            fi
          else
            shellpen -- errors argumentError '%s\n%s' 'Invalid arguments' "Command: shellpen ${__shellpen__originalCliCommands[*]}"
            return 1
          fi
        ## @
  
            ;;
        "hasFilePath")
        ## @command shellpen sources hasFilePath
          shellpen sources getFilePath "$@" >/dev/null
        ## @
  
            ;;
        "list")
        ## @command shellpen sources list
          local __shellpen__sources_list_sourceName=''
          [ $# -eq 2 ] && [ "$1" = "-" ] && eval "$2=()"
          for __shellpen__sources_list_sourceName in "${_SHELLPEN_SOURCES[@]}"
          do
            if [ $# -eq 2 ] && [ "$1" = "-" ]
            then
              eval "$2+=(\"\$__shellpen__sources_list_sourceName\")"
            else
              echo "$__shellpen__sources_list_sourceName"
            fi
          done
        ## @
  
            ;;
        "new")
        ## @command shellpen sources new
          ## $ sources new
          ##
          ## $1 Optional source name (else randomly generated)
          ## $2 Optional path to file for this source to represent
          ## $@ If `-` provided, following array argument will be cleared and appended with source names.
          ##
          ## ### Valid signatures:
          ##
          ## - [1] name
          ## - [2] name -
          ## - [2] name filePath
          ## - [2] - varName
          ## - [3] name filePath -
          ## - [3] name - varName
          ## - [4] name filePath - varName
          
          local __shellpen__sources_new_newSourceName=''
          local __shellpen__sources_new_sourceFilePath=''
          local __shellpen__sources_new_shouldOutputName=false
          local __shellpen__sources_new_outputVariableName=''
          
          if [ $# -eq 1 ]
          then
            __shellpen__sources_new_newSourceName="$1"
          elif [ $# -eq 2 ]
          then
            if [ "$1" = '-' ]
            then
              __shellpen__sources_new_shouldOutputName=true
              __shellpen__sources_new_outputVariableName="$2"
            elif [ "$2" = '-' ]
            then
              __shellpen__sources_new_newSourceName="$1"
              __shellpen__sources_new_outputVariableName="$1"
              __shellpen__sources_new_shouldOutputName=true
            else
              __shellpen__sources_new_newSourceName="$1"
              __shellpen__sources_new_sourceFilePath="$2"
            fi
          elif [ $# -eq 3 ]
          then
            if [ "$2" = '-' ]
            then
              __shellpen__sources_new_newSourceName="$1"
              __shellpen__sources_new_shouldOutputName=true
              __shellpen__sources_new_outputVariableName="$2"
            elif [ "$3" = '-' ]
            then
              __shellpen__sources_new_newSourceName="$1"
              __shellpen__sources_new_sourceFilePath="$2"
              __shellpen__sources_new_shouldOutputName=true
              __shellpen__sources_new_outputVariableName="$1"
            else
              shellpen -- errors argumentError '%s\n%s' 'Invalid arguments' "Command: shellpen ${__shellpen__originalCliCommands[*]}"
              return 1
            fi
          elif [ $# -eq 4 ]
          then
            if [ "$3" = '-' ]
            then
              __shellpen__sources_new_newSourceName="$1"
              __shellpen__sources_new_sourceFilePath="$2"
              __shellpen__sources_new_shouldOutputName=true
              __shellpen__sources_new_outputVariableName="$4"
            else
              shellpen -- errors argumentError '%s\n%s' 'Invalid arguments' "Command: shellpen ${__shellpen__originalCliCommands[*]}"
              return 1
            fi
          else
            shellpen -- errors argumentError '%s\n%s' 'Invalid arguments' "Command: shellpen ${__shellpen__originalCliCommands[*]}"
            return 1
          fi
          
          # if output variable, verify that it's a valid looking variable name, yo
          
          if shellpen sources exists "$__shellpen__sources_new_newSourceName"
          then
            shellpen -- errors argumentError '%s\n%s' "Source '$__shellpen__sources_new_newSourceName' already exists" "Command: shellpen ${__shellpen__originalCliCommands[*]}"
            return 1
          fi
          
          [ -z "$__shellpen__sources_new_newSourceName" ] && __shellpen__sources_new_newSourceName="$( cat /dev/urandom | base64 | tr -dc 'a-zA-Z0-9' | fold -w 32 | head -n 1 )"
          
          if [ "$__shellpen__sources_new_shouldOutputName" = true ]
          then
            printf -v "$__shellpen__sources_new_outputVariableName" '%s' "$__shellpen__sources_new_newSourceName" 
          fi
          
          _SHELLPEN_SOURCES+=("$__shellpen__sources_new_newSourceName")
          _SHELLPEN_SOURCES_FILE_PATHS+=("$__shellpen__sources_new_sourceFilePath")
          _SHELLPEN_SOURCECODE+=("")
          _SHELLPEN_INDENT_LEVELS+=(0)
          _SHELLPEN_OPTION_OPEN+=("")
          _SHELLPEN_FUNCTION_OPEN+=("")
          _SHELLPEN_CASE_OPEN+=("")
          _SHELLPEN_MAIN_FUNCTION+=("")
        ## @
  
            ;;
        "putAway")
        ## @command shellpen sources putAway
          if [ $# -eq 1 ]
          then
            local __shellpen__sources_putAway_sourceIndex=''
            if shellpen -- getSourceIndex "$1" - __shellpen__sources_putAway_sourceIndex
            then
          
              unset "_SHELLPEN_SOURCES[$__shellpen__sources_putAway_sourceIndex]"
              unset "_SHELLPEN_SOURCECODE[$__shellpen__sources_putAway_sourceIndex]"
              unset "_SHELLPEN_SOURCES_FILE_PATHS[$__shellpen__sources_putAway_sourceIndex]"
              unset "_SHELLPEN_INDENT_LEVELS[$__shellpen__sources_putAway_sourceIndex]"
              unset "_SHELLPEN_FUNCTION_OPEN[$__shellpen__sources_putAway_sourceIndex]"
              unset "_SHELLPEN_CASE_OPEN[$__shellpen__sources_putAway_sourceIndex]"
              unset "_SHELLPEN_MAIN_FUNCTION[$__shellpen__sources_putAway_sourceIndex]"
          
              _SHELLPEN_SOURCES=("${_SHELLPEN_SOURCES[@]}")
              _SHELLPEN_SOURCECODE=("${_SHELLPEN_SOURCECODE[@]}")
              _SHELLPEN_SOURCES_FILE_PATHS=("${_SHELLPEN_SOURCES_FILE_PATHS[@]}")
              _SHELLPEN_INDENT_LEVELS=("${_SHELLPEN_INDENT_LEVELS[@]}")
              _SHELLPEN_FUNCTION_OPEN=("${_SHELLPEN_FUNCTION_OPEN[@]}")
              _SHELLPEN_CASE_OPEN=("${_SHELLPEN_CASE_OPEN[@]}")
              _SHELLPEN_MAIN_FUNCTION=("${_SHELLPEN_MAIN_FUNCTION[@]}")
          
              if [ "$_SHELLPEN_CURRENT_SOURCE_INDEX" = "$__shellpen__sources_putAway_sourceIndex" ]
              then
                _SHELLPEN_CURRENT_SOURCE_INDEX=0
                _SHELLPEN_CURRENT_SOURCE_NAME="default"
              fi
          
            else
              shellpen -- errors argumentError '%s\n%s' "Source '$1' does not exist" "Command: shellpen ${__shellpen__originalCliCommands[*]}"
              return 1
            fi
          else
            shellpen -- errors argumentError '%s\n%s' 'Invalid arguments' "Command: shellpen ${__shellpen__originalCliCommands[*]}"
            return 1
          fi
        ## @
  
            ;;
        "use")
        ## @command shellpen sources use
          if [ $# -eq 1 ]
          then
            local __shellpen__sources_use_sourceIndex=''
            if shellpen -- getSourceIndex "$1" - __shellpen__sources_use_sourceIndex
            then
              _SHELLPEN_CURRENT_SOURCE_INDEX="$__shellpen__sources_use_sourceIndex"
            else
              shellpen -- errors argumentError '%s\n%s' "Source '$1' does not exist" "Command: shellpen ${__shellpen__originalCliCommands[*]}"
              return 1
            fi
          else
            shellpen -- errors argumentError '%s\n%s' 'Invalid arguments' "Command: shellpen ${__shellpen__originalCliCommands[*]}"
            return 1
          fi
        ## @
  
            ;;
        *)
          echo "Unknown 'shellpen sources' command: $__shellpen__mainCliCommands_command2" >&2
          return 1
          ;;
      esac
    ## @

        ;;
    "source")
    ## @command shellpen source
      shellpen sources new "$@"
    ## @

        ;;
    *)
      echo "Unknown 'shellpen' command: $__shellpen__mainCliCommands_command1" >&2
      ;;
  esac

}
#! /usr/bin/env bash

CASE_ESAC_VERSION="2.0.0"

CASE_ESAC_FILE_PROCESSORS=(
  "caseEsac -- file processors partialIncludes"
  "caseEsac -- file processors commandInlining"
  "caseEsac -- file processors originalArguments"
  "caseEsac -- file processors commandList"
  "caseEsac -- file processors commandName"
  "caseEsac -- file processors functionName"
  "caseEsac -- file processors lovelyErrors"
  "caseEsac -- file processors localPrefixes"
)

CASE_ESAC_FUNCTION_NAME=''
CASE_ESAC_SOURCE_ROOT_PATH=''
CASE_ESAC_OUTPUT_FILE_PATH=''

CASE_ESAC_COMMAND_ROOT_FILE="${CASE_ESAC_COMMAND_ROOT_FILE:-.index.sh}"
CASE_ESAC_FILE_HEADER="${CASE_ESAC_FILE_HEADER:-.fileHeader.sh}"
CASE_ESAC_FILE_FOOTER="${CASE_ESAC_FILE_FOOTER:-.fileFooter.sh}"

CASE_ESAC_LOCALS_PREFIXING="${CASE_ESAC_LOCALS_PREFIXING:-false}"
CASE_ESAC_LOCALS_PREFIX="${CASE_ESAC_LOCALS_PREFIX:-__!command__}"


CASE_ESAC_COMMAND_LIST_KEYWORD="${CASE_ESAC_COMMAND_LIST_KEYWORD:-!commands}"
CASE_ESAC_COMMAND_LIST_VARIABLE="${CASE_ESAC_COMMAND_LIST_VARIABLE:-__!fn__command}" # TEST ME

CASE_ESAC_HASHBANG="${CASE_ESAC_HASHBANG:-#! /usr/bin/env bash}"

CASE_ESAC_FUNCTION_HEADER="${CASE_ESAC_FUNCTION_HEADER:-.functionHeader.sh}" # TEST ME
CASE_ESAC_CHECK_SYNTAX="${CASE_ESAC_CHECK_SYNTAX:-true}" # TEST ME
CASE_ESAC_INCLUDE_KEYWORD="${CASE_ESAC_INCLUDE_KEYWORD:-!include}" # TEST ME
CASE_ESAC_INLINE_KEYWORD="${CASE_ESAC_INLINE_KEYWORD:-!inline}" # TEST ME
CASE_ESAC_FUNCTION_NAME_KEYWORD="${CASE_ESAC_FUNCTION_NAME_KEYWORD:-!fn}" # TEST ME
CASE_ESAC_UPPERCASE_FUNCTION_NAME_KEYWORD="${CASE_ESAC_UPPERCASE_FUNCTION_NAME_KEYWORD:-!FN}" # TEST ME
CASE_ESAC_COMMAND_NAME_KEYWORD="${CASE_ESAC_COMMAND_NAME_KEYWORD:-!command}" # TEST ME
CASE_ESAC_ERROR_KEYWORD="${CASE_ESAC_ERROR_KEYWORD:-!error}" # TEST ME
CASE_ESAC_ERROR_MESSAGE="${CASE_ESAC_ERROR_MESSAGE:-An error occurred}" # TEST ME
CASE_ESAC_ERROR_PREFIX="${CASE_ESAC_ERROR_PREFIX:-\\\`!command\\\`}" # TEST ME
CASE_ESAC_ERROR_NO_ARGUMENTS="${CASE_ESAC_ERROR_NO_ARGUMENTS:-!error \" Arguments are required but none were provided\"}" # TEST ME
CASE_ESAC_ARGUMENTS_KEYWORD="${CASE_ESAC_ARGUMENTS_KEYWORD:-!args}" # TEST ME
CASE_ESAC_ARGUMENTS_VARIABLE="${CASE_ESAC_ARGUMENTS_VARIABLE:-__!fn__args}" # TEST ME
CASE_ESAC_SILENCE_STACKTRACE_VARIABLE="${CASE_ESAC_SILENCE_STACKTRACE_VARIABLE:-\$!FN_SILENCE}" # TEST ME
CASE_ESAC_SILENCE_STACKTRACE_FILE_LOC_VARIABLE="${CASE_ESAC_SILENCE_STACKTRACE_FILE_LOC_VARIABLE:-\$!FN_SILENCE_LOC}" # TEST ME
CASE_ESAC_SILENCE_STACKTRACE_SKIP_VARIABLE="${CASE_ESAC_SILENCE_STACKTRACE_LEVELS_VARIABLE:-\$!FN_STACKTRACE_SKIP}" # TEST ME
CASE_ESAC_SILENCE_STACKTRACE_MAX_DEPTH_VARIABLE="${CASE_ESAC_SILENCE_STACKTRACE_MAX_DEPTH_VARIABLE:-\$!FN_STACKTRACE_MAX_DEPTH}" # TEST ME

CASE_ESAC_LOCALS_PRESERVE_COMMENT="${CASE_ESAC_LOCALS_PRESERVE_COMMENT:-:shared:}"

## @command caseEsac
caseEsac() {
  declare -a __caseEsac__mainCliCommands=("caseEsac")
  declare -a __caseEsac__originalCliCommands=("$@")

  local __caseEsac__mainCliCommandDepth="1"
  __caseEsac__mainCliCommands+=("$1")
  local __caseEsac__mainCliCommands_command1="$1"
  shift
  case "$__caseEsac__mainCliCommands_command1" in
    "--")
    ## @command caseEsac --
      local __caseEsac__mainCliCommandDepth="2"
      __caseEsac__mainCliCommands+=("$1")
      local __caseEsac__mainCliCommands_command2="$1"
      shift
      case "$__caseEsac__mainCliCommands_command2" in
        "appendFile")
        ## @command caseEsac -- appendFile
          local __caseEsac__processedFileSource=''
          
          CASE_ESAC_SOURCE_FILE_PATH="$1" # GET RID OF THIS, then bring it back, but I don't think it's really used TODO log.log
          
          caseEsac -- file parse "$1" "$(<"$1")" __caseEsac__processedFileSource
          
          - appendln "$( printf '%s' "$__caseEsac__processedFileSource" | sed "s/^/$( - indentation )/" )"
        ## @
  
            ;;
        "appendText")
        ## @command caseEsac -- appendText
          local __caseEsac__processedFileSource=''
          caseEsac -- file parse "" "$1" __caseEsac__processedFileSource
          
          # TODO FIXME isn't this the same as writeln? log.log
          - appendln "$( printf '%s' "$__caseEsac__processedFileSource" | sed "s/^/$( - indentation )/" )"
        ## @
  
            ;;
        "caseForDirectory")
        ## @command caseEsac -- caseForDirectory
          ## > Creates a `case`/`easc` for the provided directory of source files!
          
          (( PARSE_CONTEXT_ID++ ))
          
          : "$(( CASE_ESAC_COMMAND_DEPTH++ ))"
          CASE_ESAC_FULL_COMMAND_NAME+=("${1##*/}")
          
          caseEsac -- gatherEligibleDirectoryItems "$1"
          
          - option "\"${1##*/}\""
          caseEsac -- function addToCommandList "${1##*/}"
          
          if [ -f "$1/$CASE_ESAC_COMMAND_ROOT_FILE" ]
          then
            caseEsac -- appendFile "$1/$CASE_ESAC_COMMAND_ROOT_FILE"
          fi
          
          caseEsac -- startCommandCase
          
          local __caseEsac__directoryItem=''
          for __caseEsac__directoryItem in "${CASE_ESAC_DIRECTORY_ITEMS[@]}"
          do
            if [ -d "$__caseEsac__directoryItem" ]
            then
              caseEsac -- caseForDirectory "$__caseEsac__directoryItem"
            elif [ -f "$__caseEsac__directoryItem" ]
            then
              caseEsac -- caseOptionForFile "$__caseEsac__directoryItem"
            fi
          done
          
          caseEsac -- wildcardOption
          
          - esac
          
          caseEsac -- function popCommandList
          - ::
          
          unset "CASE_ESAC_FULL_COMMAND_NAME[$(( ${#CASE_ESAC_FULL_COMMAND_NAME[@]} - 1 ))]"
          : "$(( CASE_ESAC_COMMAND_DEPTH-- ))"
        ## @
  
            ;;
        "caseOptionForFile")
        ## @command caseEsac -- caseOptionForFile
          
          (( PARSE_CONTEXT_ID++ ))
          
          local __caseEsac__optionNameForFile="${1##*/}"
          __caseEsac__optionNameForFile="${__caseEsac__optionNameForFile%\.*}"
          
          CASE_ESAC_FULL_COMMAND_NAME+=("$__caseEsac__optionNameForFile")
          
          - option "\"$__caseEsac__optionNameForFile\""
          caseEsac -- function addToCommandList "$__caseEsac__optionNameForFile"
            caseEsac -- appendFile "$1"
            caseEsac -- function popCommandList
            - ::
          
          unset "CASE_ESAC_FULL_COMMAND_NAME[$(( ${#CASE_ESAC_FULL_COMMAND_NAME[@]} - 1 ))]"
        ## @
  
            ;;
        "commandNotFound")
        ## @command caseEsac -- commandNotFound
          - error "Command not found: '\$__${CASE_ESAC_FUNCTION_NAME}__$(( CASE_ESAC_COMMAND_DEPTH ))'"
        ## @
  
            ;;
        "errors")
        ## @command caseEsac -- errors
            local __caseEsac__mainCliCommandDepth="3"
            __caseEsac__mainCliCommands+=("$1")
            local __caseEsac__mainCliCommands_command3="$1"
            shift
            case "$__caseEsac__mainCliCommands_command3" in
              "argumentError")
              ## @command caseEsac -- errors argumentError
                if [ $# -gt 0 ]
                then
                  printf '`caseEsac` [Argument Error] ' >&2
                  printf "$@" >&2
                else
                  printf '`caseEsac` [Argument Error]' >&2
                fi
                caseEsac -- errors printStackTrace
              ## @
      
                  ;;
              "compileError")
              ## @command caseEsac -- errors compileError
                if [ $# -gt 0 ]
                then
                  printf '`caseEsac` [Compilation Error] ' >&2
                  printf "$@" >&2
                else
                  printf '`caseEsac` [Compilation Error]' >&2
                fi
                caseEsac -- errors printStackTrace
              ## @
      
                  ;;
              "generalError")
              ## @command caseEsac -- errors generalError
                if [ $# -gt 0 ]
                then
                  printf '`caseEsac` [Error] ' >&2
                  printf "$@" >&2
                else
                  printf '`caseEsac` [Error]' >&2
                fi
                caseEsac -- errors printStackTrace
              ## @
      
                  ;;
              "getFileLine")
              ## @command caseEsac -- errors getFileLine
                ## $1 Path to the file
                ## $2 Line to print
                ##
                if [ "$2" = "0" ]
                then
                  sed "1q;d" "$1" | sed 's/^ *//g'
                else
                  sed "${2}q;d" "$1" | sed 's/^ *//g'
                fi
              ## @
      
                  ;;
              "printStackTrace")
              ## @command caseEsac -- errors printStackTrace
                ## $1 (_Optional_) How many levels to skip (default: `2`)
                ## $2 (_Optional_) How many levels deep to show (default: `100`)
                
                local __shellpen__x_errors_printStackTrace_levelsToSkip="${1-3}"
                local __shellpen__x_errors_printStackTrace_levelsToShow="${2-100}"
                
                if [ "$SHELLPEN_SILENCE" != "true" ]
                then
                  echo >&2
                  echo >&2
                  echo "Stacktrace:" >&2
                  echo >&2
                  local __shellpen__i=1
                  local __shellpen__stackIndex="$__shellpen__x_errors_printStackTrace_levelsToSkip"
                  while [ $__shellpen__stackIndex -lt ${#BASH_SOURCE[@]} ] && [ $__shellpen__i -lt $__shellpen__x_errors_printStackTrace_levelsToShow ]
                  do
                    local __shellpen__errors_printStackTrace_line=''
                    __shellpen__errors_printStackTrace_line="$( echo "$(caseEsac -- errors getFileLine "${BASH_SOURCE[$__shellpen__stackIndex]}" "${BASH_LINENO[$(( __shellpen__stackIndex - 1 ))]}")" | sed 's/^/    /' 2>&1 )"
                    # Catches sed errors
                    if [ $? -eq 0 ]
                    then
                      echo "${BASH_SOURCE[$__shellpen__stackIndex]}:${BASH_LINENO[$(( __shellpen__stackIndex - 1 ))]} ${FUNCNAME[$__shellpen__stackIndex]}():" >&2
                      echo "  $__shellpen__errors_printStackTrace_line" >&2
                    else
                      echo "${BASH_SOURCE[$__shellpen__stackIndex]}:${BASH_LINENO[$(( __shellpen__stackIndex - 1 ))]} ${FUNCNAME[$__shellpen__stackIndex]}()" >&2
                    fi
                    echo >&2
                    : "$(( __shellpen__stackIndex++ ))"
                    : "$(( __shellpen__i++ ))"
                  done
                fi
              ## @
      
                  ;;
              *)
                echo "Unknown 'caseEsac -- errors' command: $__caseEsac__mainCliCommands_command3" >&2
                return 1
                ;;
            esac
        ## @
  
            ;;
        "file")
        ## @command caseEsac -- file
            local __caseEsac__mainCliCommandDepth="3"
            __caseEsac__mainCliCommands+=("$1")
            local __caseEsac__mainCliCommands_command3="$1"
            shift
            case "$__caseEsac__mainCliCommands_command3" in
              "findCommandInlinePaths")
              ## @command caseEsac -- file findCommandInlinePaths
                ## $1 Friendly command name from the !inline
                ## $2 Name of array output variable to add paths to include to
                ## @return 0 If found
                ## @return 1 If not found
                
                local __caseEsac__file_findCommandInlinePath_expectedPath="${CASE_ESAC_SOURCE_ROOT_PATH%/}/${1// //}"
                
                if [ -f "${__caseEsac__file_findCommandInlinePath_expectedPath}.sh" ]
                then
                  if [ -f "${__caseEsac__file_findCommandInlinePath_expectedPath%/*}/$CASE_ESAC_COMMAND_ROOT_FILE" ]
                  then
                    eval "$2+=(\"\${__caseEsac__file_findCommandInlinePath_expectedPath%/*}/\$CASE_ESAC_COMMAND_ROOT_FILE\")"
                  fi
                  eval "$2+=(\"\${__caseEsac__file_findCommandInlinePath_expectedPath}.sh\")"
                fi
                
                if [ -d "$__caseEsac__file_findCommandInlinePath_expectedPath" ]
                then
                  if [ -f "${__caseEsac__file_findCommandInlinePath_expectedPath%/}/$CASE_ESAC_COMMAND_ROOT_FILE" ]
                  then
                    eval "$2+=(\"\${__caseEsac__file_findCommandInlinePath_expectedPath%/}/\$CASE_ESAC_COMMAND_ROOT_FILE\")"
                  fi
                fi
              ## @
      
                  ;;
              "findPartialPath")
              ## @command caseEsac -- file findPartialPath
                ## $1 Friendly path of partial defined in the !include
                ## $2 Name of output variable to set discovered path to
                ## @return 0 If found
                ## @return 1 If not found
                
                # CASE_ESAC_SOURCE_FILE_PATH
                # CASE_ESAC_SOURCE_ROOT_PATH
                
                local __caseEsac_file_findPartialPath_currentDirectory="${CASE_ESAC_SOURCE_FILE_PATH%/*}"
                local __caseEsac_file_findPartialPath_sourceRootPath="${CASE_ESAC_SOURCE_ROOT_PATH%/}"
                
                if [ -f "$__caseEsac_file_findPartialPath_currentDirectory/.$1" ]
                then
                  printf -v "$2" '%s' "$__caseEsac_file_findPartialPath_currentDirectory/.$1"
                  return 0
                elif [ -f "$__caseEsac_file_findPartialPath_currentDirectory/.$1.sh" ]
                then
                  printf -v "$2" '%s' "$__caseEsac_file_findPartialPath_currentDirectory/.$1.sh"
                  return 0
                fi
                
                while [ "$__caseEsac_file_findPartialPath_currentDirectory" != "$__caseEsac_file_findPartialPath_sourceRootPath" ] && [ -n "$__caseEsac_file_findPartialPath_currentDirectory" ]
                do
                  __caseEsac_file_findPartialPath_currentDirectory="${__caseEsac_file_findPartialPath_currentDirectory%/*}"
                  if [ -f "$__caseEsac_file_findPartialPath_currentDirectory/.$1" ]
                  then
                    printf -v "$2" '%s' "$__caseEsac_file_findPartialPath_currentDirectory/.$1"
                    return 0
                  elif [ -f "$__caseEsac_file_findPartialPath_currentDirectory/.$1.sh" ]
                  then
                    printf -v "$2" '%s' "$__caseEsac_file_findPartialPath_currentDirectory/.$1.sh"
                    return 0
                  fi
                done
                
                return 1
              ## @
      
                  ;;
              "footer")
              ## @command caseEsac -- file footer
                [ -f "$CASE_ESAC_SOURCE_ROOT_PATH/$CASE_ESAC_FILE_FOOTER" ] && caseEsac -- appendFile "$CASE_ESAC_SOURCE_ROOT_PATH/$CASE_ESAC_FILE_FOOTER"
              ## @
      
                  ;;
              "header")
              ## @command caseEsac -- file header
                [ -f "$CASE_ESAC_SOURCE_ROOT_PATH/$CASE_ESAC_FILE_HEADER" ] && caseEsac -- appendFile "$CASE_ESAC_SOURCE_ROOT_PATH/$CASE_ESAC_FILE_HEADER"
              ## @
      
                  ;;
              "parse")
              ## @command caseEsac -- file parse
                ## $1 Source path (may be blank)
                ## $2 Source content
                ## $3 Output string variable name
                ##
                ## > Parse a file and make configured replacements, if any.
                
                # TODO REMOVE ME: log.log
                CASE_ESAC_SOURCE_FILE_PATH="$1"
                CASE_ESAC_SOURCE_RELATIVE_FILE_PATH="${1#$CASE_ESAC_SOURCE_ROOT_PATH}"
                CASE_ESAC_SOURCE_RELATIVE_FILE_PATH="${CASE_ESAC_SOURCE_RELATIVE_FILE_PATH#/}"
                
                local __caseEsac__file_parse_newLine=$'\n'
                local __caseEsac__file_parse_outputSourceContent="$2"
                local __caseEsac__file_parse_processedOutputSourceContent="$__caseEsac__file_parse_outputSourceContent"
                
                while true
                do
                
                  # Give each processor a shot at changing the content!
                  local CASE_ESAC_FILE_PROCESSOR=''
                  for CASE_ESAC_FILE_PROCESSOR in "${CASE_ESAC_FILE_PROCESSORS[@]}"
                  do
                    local __caseEsac__file_parse_processorOutputFile="$( mktemp )"
                
                    $CASE_ESAC_FILE_PROCESSOR "$__caseEsac__file_parse_processedOutputSourceContent" 2>&1 1>"$__caseEsac__file_parse_processorOutputFile"
                    [ $? -eq 2 ] && return 2
                
                    __caseEsac__file_parse_processedOutputSourceContent="$(<"$__caseEsac__file_parse_processorOutputFile")"
                    [ -f "$__caseEsac__file_parse_processorOutputFile" ] && rm "$__caseEsac__file_parse_processorOutputFile"
                  done
                
                  # Continue until the processors don't change the source anymore
                  if [ "$__caseEsac__file_parse_outputSourceContent" = "$__caseEsac__file_parse_processedOutputSourceContent" ]
                  then
                    break
                  else
                    __caseEsac__file_parse_outputSourceContent="$__caseEsac__file_parse_processedOutputSourceContent"
                  fi
                done
                
                CASE_ESAC_FILE_PROCESSOR=''
                CASE_ESAC_SOURCE_FILE_PATH="$PREVIOUS_SOURCE_FILE_PATH"
                CASE_ESAC_SOURCE_RELATIVE_FILE_PATH=''
                
                printf -v "$3" '%s' "$__caseEsac__file_parse_processedOutputSourceContent"
              ## @
      
                  ;;
              "processors")
              ## @command caseEsac -- file processors
                    local __caseEsac__mainCliCommandDepth="4"
                    __caseEsac__mainCliCommands+=("$1")
                    local __caseEsac__mainCliCommands_command4="$1"
                    shift
                    case "$__caseEsac__mainCliCommands_command4" in
                      "commandInlining")
                      ## @command caseEsac -- file processors commandInlining
                        local __caseEsac_file_processors_commandInlining_newLine=$'\n'
                        local __caseEsac_file_processors_commandInlining_outputContent=''
                        local __caseEsac_file_processors_commandInlining_inputFileLine=''
                        while IFS="" read -r __caseEsac_file_processors_commandInlining_inputFileLine || [ -n "$__caseEsac_file_processors_commandInlining_inputFileLine" ]
                        do
                          if [[ "$__caseEsac_file_processors_commandInlining_inputFileLine" =~ ^[[:space:]]*\!inline[[:space:]](.*)$ ]]
                          then
                            __caseEsac_file_processors_commandInlining_command="${BASH_REMATCH[1]}"
                            declare -a __caseEsac_file_processors_commandInlining_commandFilePaths=()
                            if caseEsac -- file findCommandInlinePaths "$__caseEsac_file_processors_commandInlining_command" __caseEsac_file_processors_commandInlining_commandFilePaths
                            then
                              local __caseEsac_file_processors_commandInlining_commandFilePath=''
                              for __caseEsac_file_processors_commandInlining_commandFilePath in "${__caseEsac_file_processors_commandInlining_commandFilePaths[@]}"
                              do
                                local __caseEsac_file_processors_commandInlining_commandContent="$(<"$__caseEsac_file_processors_commandInlining_commandFilePath")${__caseEsac_file_processors_commandInlining_newLine}"
                                __caseEsac_file_processors_commandInlining_outputContent+="$__caseEsac_file_processors_commandInlining_commandContent"
                              done
                            else
                              caseEsac -- errors generalError '%s\n%s' "Could not find command '$__caseEsac_file_processors_commandInlining_command' defined in '$CASE_ESAC_SOURCE_FILE_PATH'" "Command: caseEsac ${__caseEsac__originalCliCommands[*]}"
                              return 1
                            fi
                          else
                            __caseEsac_file_processors_commandInlining_outputContent+="${__caseEsac_file_processors_commandInlining_inputFileLine}${__caseEsac_file_processors_commandInlining_newLine}"
                          fi
                        done < <( printf '%s' "$1" )
                        
                        printf '%s' "$__caseEsac_file_processors_commandInlining_outputContent"
                      ## @
            
                          ;;
                      "commandList")
                      ## @command caseEsac -- file processors commandList
                        printf '%s' "$1" | sed "s/$CASE_ESAC_COMMAND_LIST_KEYWORD/$CASE_ESAC_COMMAND_LIST_VARIABLE/g"
                      ## @
            
                          ;;
                      "commandName")
                      ## @command caseEsac -- file processors commandName
                        printf '%s' "$1" | sed "s/$CASE_ESAC_COMMAND_NAME_KEYWORD/${CASE_ESAC_FULL_COMMAND_NAME[*]}/g"
                      ## @
            
                          ;;
                      "functionName")
                      ## @command caseEsac -- file processors functionName
                        printf '%s' "$1" | sed "s/$CASE_ESAC_FUNCTION_NAME_KEYWORD/$CASE_ESAC_FUNCTION_NAME/g" | sed "s/$CASE_ESAC_UPPERCASE_FUNCTION_NAME_KEYWORD/$( echo "$CASE_ESAC_FUNCTION_NAME" | tr [:lower:] [:upper:] )/g"
                      ## @
            
                          ;;
                      "localPrefixes_ORIGINAL")
                      ## @command caseEsac -- file processors localPrefixes_ORIGINAL
                        local __caseEsac_file_processors_localPrefixes_newLine=$'\n'
                        local __caseEsac_file_processors_localPrefixes_outputContent=''
                        local __caseEsac_file_processors_localPrefixes_inputFileLine=''
                        
                        # Variable names and their replacements (which can be customized)
                        declare -a __caseEsac_file_processors_localPrefixes_localVariableNames=()
                        declare -a __caseEsac_file_processors_localPrefixes_localVariableReplacementNames=()
                        
                        # Scan for locals
                        while IFS="" read -r __caseEsac_file_processors_localPrefixes_inputFileLine || [ -n "$__caseEsac_file_processors_localPrefixes_inputFileLine" ]
                        do
                          # Figure out why this is getting so many blank lines, something is wicked broken here.
                          # It results in this running *wicked* slowly. What is up? Debug this file logic
                          [ -z "$__caseEsac_file_processors_localPrefixes_inputFileLine" ] && continue
                        
                          local __caseEsac_file_processors_localPrefixes_stagedOutputContent=''
                        
                          # local x
                          # local x=something
                          if [[ "$__caseEsac_file_processors_localPrefixes_inputFileLine" =~ ^[[:space:]]*local[[:space:]]([^=]*)[=]*(.*) ]]
                          then
                            # check for :shared:
                            if [[ "$__caseEsac_file_processors_localPrefixes_inputFileLine" = *":shared:"* ]] # Add config option to name this
                            then
                              __caseEsac_file_processors_localPrefixes_stagedOutputContent+="${__caseEsac_file_processors_localPrefixes_inputFileLine}${__caseEsac_file_processors_localPrefixes_newLine}"
                            else
                              local __caseEsac_file_processors_localPrefixes_localName="${BASH_REMATCH[1]}"
                              local __caseEsac_file_processors_localPrefixes_localValue="${BASH_REMATCH[2]}"
                              if caseEsac -- previouslyReplacedLocalName TEXT "$__caseEsac_file_processors_localPrefixes_localName" "$__caseEsac_file_processors_localPrefixes_localValue"
                              then
                                __caseEsac_file_processors_localPrefixes_stagedOutputContent+="${__caseEsac_file_processors_localPrefixes_inputFileLine}${__caseEsac_file_processors_localPrefixes_newLine}"
                              else
                                local __caseEsac_file_processors_localPrefixes_variableReplacementName=''
                                caseEsac -- getLocalVariableReplacementName TEXT "$__caseEsac_file_processors_localPrefixes_localName" "$__caseEsac_file_processors_localPrefixes_localValue" __caseEsac_file_processors_localPrefixes_variableReplacementName
                                __caseEsac_file_processors_localPrefixes_localVariableNames+=("$__caseEsac_file_processors_localPrefixes_localName")
                                __caseEsac_file_processors_localPrefixes_localVariableReplacementNames+=("$__caseEsac_file_processors_localPrefixes_variableReplacementName")
                                # Add config option for sure. Default local value.
                                if [ -z "$__caseEsac_file_processors_localPrefixes_localValue" ]
                                then
                                  __caseEsac_file_processors_localPrefixes_stagedOutputContent+="${__caseEsac_file_processors_localPrefixes_inputFileLine/local $__caseEsac_file_processors_localPrefixes_localName/local $__caseEsac_file_processors_localPrefixes_variableReplacementName}=''${__caseEsac_file_processors_localPrefixes_newLine}"
                                else
                                  __caseEsac_file_processors_localPrefixes_stagedOutputContent+="${__caseEsac_file_processors_localPrefixes_inputFileLine/local $__caseEsac_file_processors_localPrefixes_localName/local $__caseEsac_file_processors_localPrefixes_variableReplacementName}${__caseEsac_file_processors_localPrefixes_newLine}"
                                fi
                              fi
                            fi
                          elif [[ "$__caseEsac_file_processors_localPrefixes_inputFileLine" =~ ^[[:space:]]*declare[[:space:]]-i[[:space:]]([^=]*)[=]*(.*) ]]
                          then
                            # check for :shared:
                            if [[ "$__caseEsac_file_processors_localPrefixes_inputFileLine" = *":shared:"* ]] # Add config option to name this
                            then
                              __caseEsac_file_processors_localPrefixes_stagedOutputContent+="${__caseEsac_file_processors_localPrefixes_inputFileLine}${__caseEsac_file_processors_localPrefixes_newLine}"
                            else
                              local __caseEsac_file_processors_localPrefixes_localName="${BASH_REMATCH[1]}"
                              local __caseEsac_file_processors_localPrefixes_localValue="${BASH_REMATCH[2]}"
                              if caseEsac -- previouslyReplacedLocalName TEXT "$__caseEsac_file_processors_localPrefixes_localName" "$__caseEsac_file_processors_localPrefixes_localValue"
                              then
                                __caseEsac_file_processors_localPrefixes_stagedOutputContent+="${__caseEsac_file_processors_localPrefixes_inputFileLine}${__caseEsac_file_processors_localPrefixes_newLine}"
                              else
                                local __caseEsac_file_processors_localPrefixes_variableReplacementName=''
                                caseEsac -- getLocalVariableReplacementName TEXT "$__caseEsac_file_processors_localPrefixes_localName" "$__caseEsac_file_processors_localPrefixes_localValue" __caseEsac_file_processors_localPrefixes_variableReplacementName
                                __caseEsac_file_processors_localPrefixes_localVariableNames+=("$__caseEsac_file_processors_localPrefixes_localName")
                                __caseEsac_file_processors_localPrefixes_localVariableReplacementNames+=("$__caseEsac_file_processors_localPrefixes_variableReplacementName")
                                # Add config option for sure. Default local value.
                                if [ -z "$__caseEsac_file_processors_localPrefixes_localValue" ]
                                then
                                  __caseEsac_file_processors_localPrefixes_stagedOutputContent+="${__caseEsac_file_processors_localPrefixes_inputFileLine/declare -i $__caseEsac_file_processors_localPrefixes_localName/declare -i $__caseEsac_file_processors_localPrefixes_variableReplacementName}=0${__caseEsac_file_processors_localPrefixes_newLine}"
                                else
                                  __caseEsac_file_processors_localPrefixes_stagedOutputContent+="${__caseEsac_file_processors_localPrefixes_inputFileLine/declare -i $__caseEsac_file_processors_localPrefixes_localName/declare -i $__caseEsac_file_processors_localPrefixes_variableReplacementName}${__caseEsac_file_processors_localPrefixes_newLine}"
                                fi
                              fi
                            fi
                          elif [[ "$__caseEsac_file_processors_localPrefixes_inputFileLine" =~ ^[[:space:]]*declare[[:space:]]-a[[:space:]]([^=]*)[=]*(.*) ]]
                          then
                            # check for :shared:
                            if [[ "$__caseEsac_file_processors_localPrefixes_inputFileLine" = *":shared:"* ]] # Add config option to name this
                            then
                              __caseEsac_file_processors_localPrefixes_stagedOutputContent+="${__caseEsac_file_processors_localPrefixes_inputFileLine}${__caseEsac_file_processors_localPrefixes_newLine}"
                            else
                              local __caseEsac_file_processors_localPrefixes_localName="${BASH_REMATCH[1]}"
                              local __caseEsac_file_processors_localPrefixes_localValue="${BASH_REMATCH[2]}"
                              if caseEsac -- previouslyReplacedLocalName TEXT "$__caseEsac_file_processors_localPrefixes_localName" "$__caseEsac_file_processors_localPrefixes_localValue"
                              then
                                __caseEsac_file_processors_localPrefixes_stagedOutputContent+="${__caseEsac_file_processors_localPrefixes_inputFileLine}${__caseEsac_file_processors_localPrefixes_newLine}"
                              else
                                local __caseEsac_file_processors_localPrefixes_variableReplacementName=''
                                caseEsac -- getLocalVariableReplacementName TEXT "$__caseEsac_file_processors_localPrefixes_localName" "$__caseEsac_file_processors_localPrefixes_localValue" __caseEsac_file_processors_localPrefixes_variableReplacementName
                                __caseEsac_file_processors_localPrefixes_localVariableNames+=("$__caseEsac_file_processors_localPrefixes_localName")
                                __caseEsac_file_processors_localPrefixes_localVariableReplacementNames+=("$__caseEsac_file_processors_localPrefixes_variableReplacementName")
                                # Add config option for sure. Default local value.
                                if [ -z "$__caseEsac_file_processors_localPrefixes_localValue" ]
                                then
                                  __caseEsac_file_processors_localPrefixes_stagedOutputContent+="${__caseEsac_file_processors_localPrefixes_inputFileLine/declare -a $__caseEsac_file_processors_localPrefixes_localName/declare -a $__caseEsac_file_processors_localPrefixes_variableReplacementName}=()${__caseEsac_file_processors_localPrefixes_newLine}"
                                else
                                  __caseEsac_file_processors_localPrefixes_stagedOutputContent+="${__caseEsac_file_processors_localPrefixes_inputFileLine/declare -a $__caseEsac_file_processors_localPrefixes_localName/declare -a $__caseEsac_file_processors_localPrefixes_variableReplacementName}${__caseEsac_file_processors_localPrefixes_newLine}"
                                fi
                              fi
                            fi
                          elif [[ "$__caseEsac_file_processors_localPrefixes_inputFileLine" =~ ^[[:space:]]*declare[[:space:]]-A[[:space:]]([^=]*)[=]*(.*) ]]
                          then
                            # check for :shared:
                            if [[ "$__caseEsac_file_processors_localPrefixes_inputFileLine" = *":shared:"* ]] # Add config option to name this
                            then
                              __caseEsac_file_processors_localPrefixes_stagedOutputContent+="${__caseEsac_file_processors_localPrefixes_inputFileLine}${__caseEsac_file_processors_localPrefixes_newLine}"
                            else
                              local __caseEsac_file_processors_localPrefixes_localName="${BASH_REMATCH[1]}"
                              local __caseEsac_file_processors_localPrefixes_localValue="${BASH_REMATCH[2]}"
                              if caseEsac -- previouslyReplacedLocalName TEXT "$__caseEsac_file_processors_localPrefixes_localName" "$__caseEsac_file_processors_localPrefixes_localValue"
                              then
                                __caseEsac_file_processors_localPrefixes_stagedOutputContent+="${__caseEsac_file_processors_localPrefixes_inputFileLine}${__caseEsac_file_processors_localPrefixes_newLine}"
                              else
                                local __caseEsac_file_processors_localPrefixes_variableReplacementName=''
                                caseEsac -- getLocalVariableReplacementName TEXT "$__caseEsac_file_processors_localPrefixes_localName" "$__caseEsac_file_processors_localPrefixes_localValue" __caseEsac_file_processors_localPrefixes_variableReplacementName
                                __caseEsac_file_processors_localPrefixes_localVariableNames+=("$__caseEsac_file_processors_localPrefixes_localName")
                                __caseEsac_file_processors_localPrefixes_localVariableReplacementNames+=("$__caseEsac_file_processors_localPrefixes_variableReplacementName")
                                # Add config option for sure. Default local value.
                                if [ -z "$__caseEsac_file_processors_localPrefixes_localValue" ]
                                then
                                  __caseEsac_file_processors_localPrefixes_stagedOutputContent+="${__caseEsac_file_processors_localPrefixes_inputFileLine/declare -A $__caseEsac_file_processors_localPrefixes_localName/declare -A $__caseEsac_file_processors_localPrefixes_variableReplacementName}=()${__caseEsac_file_processors_localPrefixes_newLine}"
                                else
                                  __caseEsac_file_processors_localPrefixes_stagedOutputContent+="${__caseEsac_file_processors_localPrefixes_inputFileLine/declare -A $__caseEsac_file_processors_localPrefixes_localName/declare -A $__caseEsac_file_processors_localPrefixes_variableReplacementName}${__caseEsac_file_processors_localPrefixes_newLine}"
                                fi
                              fi
                            fi
                          else
                            __caseEsac_file_processors_localPrefixes_stagedOutputContent+="${__caseEsac_file_processors_localPrefixes_inputFileLine}${__caseEsac_file_processors_localPrefixes_newLine}"
                          fi
                        
                          local __caseEsac_file_processors_localPrefixes_replacementInputLine="$__caseEsac_file_processors_localPrefixes_stagedOutputContent"
                          local __caseEsac_file_processors_localPrefixes_finalLineResult="$__caseEsac_file_processors_localPrefixes_replacementInputLine"
                          #
                        
                          while true
                          do
                        
                            local __caseEsac_file_processors_localPrefixes_localNameToReplaceIndex=''
                            for __caseEsac_file_processors_localPrefixes_localNameToReplaceIndex in "${!__caseEsac_file_processors_localPrefixes_localVariableNames[@]}"
                            do
                              local __caseEsac_file_processors_localPrefixes_varName="${__caseEsac_file_processors_localPrefixes_localVariableNames[$__caseEsac_file_processors_localPrefixes_localNameToReplaceIndex]}"
                              local __caseEsac_file_processors_localPrefixes_replacementName="${__caseEsac_file_processors_localPrefixes_localVariableReplacementNames[$__caseEsac_file_processors_localPrefixes_localNameToReplaceIndex]}"
                        
                              # $ Variables
                              if [[ "$__caseEsac_file_processors_localPrefixes_replacementInputLine" =~ ^(.*)\$([{]?)([\!\#]?)$__caseEsac_file_processors_localPrefixes_varName([^a-zA-Z0-9_]*)(.*) ]]
                              then
                                local __caseEsac_file_processors_localPrefixes_replacedText="${BASH_REMATCH[1]}\$${BASH_REMATCH[2]}${BASH_REMATCH[3]}${__caseEsac_file_processors_localPrefixes_replacementName}${BASH_REMATCH[4]}${BASH_REMATCH[5]}"
                                if ! [[ "$__caseEsac_file_processors_localPrefixes_replacementInputLine" =~ ^(.*)\$([{]?)([\!\#]?)$__caseEsac_file_processors_localPrefixes_replacementName([^a-zA-Z0-9_]*)(.*) ]]
                                then
                                  __caseEsac_file_processors_localPrefixes_finalLineResult="${__caseEsac_file_processors_localPrefixes_replacedText}"
                                fi
                              # Arithmetic
                              elif [[ "$__caseEsac_file_processors_localPrefixes_replacementInputLine" =~ ^(.*)\(\((.*)$__caseEsac_file_processors_localPrefixes_varName(.*)\)\)(.*) ]]
                              then
                                local __caseEsac_file_processors_localPrefixes_replacedText="${BASH_REMATCH[1]}((${BASH_REMATCH[2]}${__caseEsac_file_processors_localPrefixes_replacementName}${BASH_REMATCH[3]}))${BASH_REMATCH[4]}"
                                if ! [[ "$__caseEsac_file_processors_localPrefixes_replacementInputLine" =~ ^(.*)\(\((.*)$__caseEsac_file_processors_localPrefixes_replacementName(.*)\)\)(.*) ]]
                                then
                                  __caseEsac_file_processors_localPrefixes_finalLineResult="${__caseEsac_file_processors_localPrefixes_replacedText}"
                                fi
                              # Assignments and Concatenations
                              elif [[ "$__caseEsac_file_processors_localPrefixes_replacementInputLine" =~ ^$__caseEsac_file_processors_localPrefixes_varName([+]?)=(.*) ]]
                              then
                                local __caseEsac_file_processors_localPrefixes_replacedText="${__caseEsac_file_processors_localPrefixes_replacementName}${BASH_REMATCH[1]}=${BASH_REMATCH[2]}"
                                __caseEsac_file_processors_localPrefixes_finalLineResult="${__caseEsac_file_processors_localPrefixes_replacedText}"
                              # for statements
                              elif [[ "$__caseEsac_file_processors_localPrefixes_replacementInputLine" =~ ^(.*)for[[:space:]]$__caseEsac_file_processors_localPrefixes_varName[[:space:]]in(.*) ]]
                              then
                                local __caseEsac_file_processors_localPrefixes_replacedText="${BASH_REMATCH[1]}for ${__caseEsac_file_processors_localPrefixes_replacementName} in${BASH_REMATCH[2]}"
                                __caseEsac_file_processors_localPrefixes_finalLineResult="${__caseEsac_file_processors_localPrefixes_replacedText}"
                              # read statements
                        
                              fi
                              #
                            done
                        
                            if [ "$__caseEsac_file_processors_localPrefixes_finalLineResult" = "$__caseEsac_file_processors_localPrefixes_replacementInputLine" ]
                            then
                              break
                            else
                              __caseEsac_file_processors_localPrefixes_replacementInputLine="$__caseEsac_file_processors_localPrefixes_finalLineResult"
                            fi
                        
                          done
                        
                          # Append to output content
                          [ -n "$__caseEsac_file_processors_localPrefixes_finalLineResult" ] && __caseEsac_file_processors_localPrefixes_outputContent+="${__caseEsac_file_processors_localPrefixes_finalLineResult}"
                        
                        done < <( printf '%s' "$1" )
                        
                        printf '%s' "$__caseEsac_file_processors_localPrefixes_outputContent"
                      ## @
            
                          ;;
                      "localPrefixes")
                      ## @command caseEsac -- file processors localPrefixes
                        if [ "$CASE_ESAC_LOCALS_PREFIXING" != true ]
                        then
                          printf '%s' "$1"
                          return 0
                        fi
                        
                        local __caseEsac__localPrefix_endResult=""
                        
                        local THIS_PARSE_CONTEXT="$PARSE_CONTEXT_ID"
                        
                        declare -p "LOCALS_FOR_$THIS_PARSE_CONTEXT" &>/dev/null       || eval "LOCALS_FOR_$THIS_PARSE_CONTEXT=()"
                        declare -p "REPLACEMENTS_FOR_$THIS_PARSE_CONTEXT" &>/dev/null || eval "REPLACEMENTS_FOR_$THIS_PARSE_CONTEXT=()"
                        
                        CASE_ESAC_LOCAL_FINDERS=(
                          "..."
                        )
                        # Find the locals in the text. Give a few loaders an opportunity to run thru the text.
                        caseEsac -- file processors localVariablePrefixes loaders simpleLocals "$1"
                        
                        ###
                        
                        CASE_ESAC_LOCAL_REPLACERS=(
                          "caseEsac -- file processors localVariablePrefixes replacers dollarVariables"
                          "caseEsac -- file processors localVariablePrefixes replacers localDeclarationVariables"
                        )
                        
                        local __caseEsac__localPrefix_NEWLINE=$'\n'
                        
                        # Update the text to use the new names!
                        # So.
                        # Here's what we'll do.
                        # We'll go thru each line.
                        # For each line, we'll give each replacer a chance to make 1 or more replacements.
                        # And we'll run replacers on that line until the line we put in is the same as the line we get out.
                        # When it's the same, we'll add it to our end result
                        local __caseEsac__localPrefix_sourceCode_LINE=''
                        while IFS="" read -r __caseEsac__localPrefix_sourceCode_LINE || [ -n "$__caseEsac__localPrefix_sourceCode_LINE" ]
                        do
                          local __caseEsac__LINE="$__caseEsac__localPrefix_sourceCode_LINE"
                          local __caseEsac__localPrefix_LINE_BeforeReplacers="$__caseEsac__LINE"
                        
                          while true
                          do
                            local __caseEsac__localPrefix_VariableReplacer=''
                            for __caseEsac__localPrefix_VariableReplacer in "${CASE_ESAC_LOCAL_REPLACERS[@]}"
                            do
                              __caseEsac__LINE="$( $__caseEsac__localPrefix_VariableReplacer "$__caseEsac__LINE" )"
                            done
                        
                            if [ "$__caseEsac__LINE" = "$__caseEsac__localPrefix_LINE_BeforeReplacers" ]
                            then
                              break
                            else
                              __caseEsac__localPrefix_LINE_BeforeReplacers="$__caseEsac__LINE"
                            fi
                          done
                        
                          __caseEsac__localPrefix_endResult+="$__caseEsac__LINE${__caseEsac__localPrefix_NEWLINE}"
                        done < <( printf '%s' "$1" )
                        
                        caseEsac -- file processors localVariablePrefixes replacers dollarVariables
                        
                        printf '%s' "$__caseEsac__localPrefix_endResult"
                      ## @
            
                          ;;
                      "localVariablePrefixes")
                      ## @command caseEsac -- file processors localVariablePrefixes
                              local __caseEsac__mainCliCommandDepth="5"
                              __caseEsac__mainCliCommands+=("$1")
                              local __caseEsac__mainCliCommands_command5="$1"
                              shift
                              case "$__caseEsac__mainCliCommands_command5" in
                                "loaders")
                                ## @command caseEsac -- file processors localVariablePrefixes loaders
                                          local __caseEsac__mainCliCommandDepth="6"
                                          __caseEsac__mainCliCommands+=("$1")
                                          local __caseEsac__mainCliCommands_command6="$1"
                                          shift
                                          case "$__caseEsac__mainCliCommands_command6" in
                                            "getStatements")
                                            ## @command caseEsac -- file processors localVariablePrefixes loaders getStatements
                                              # Load up an array with statements (split on ;, &&, and ||)
                                              # This may not be accurate, whatsover.
                                              # This is perfect for our needs tho!
                                              # We just want to do what we can to split up
                                              # what could be multiple local declarations on one line.
                                              
                                              declare -a CASE_ESAC_LOC_BASH_STATEMENTS=()
                                              
                                              # First split on ;
                                              declare -a __caseEsac__SEMICOLON_STATEMENTS=()
                                              IFS=';' read -a __caseEsac__SEMICOLON_STATEMENTS < <( printf '%s' "$1" )
                                              
                                              # Next split on &&. Ok. Well, actually, we just split on '&'. Yay IFS.
                                              declare -a __caseEsac__AND_STATEMENTS=()
                                              
                                              local __caseEsac__SEMICOLON_STATEMENT=''
                                              for __caseEsac__SEMICOLON_STATEMENT in "${__caseEsac__SEMICOLON_STATEMENTS[@]}"
                                              do
                                                declare -a __caseEsac__AND_sub_STATEMENTS=()
                                                IFS='&' read -a __caseEsac__AND_sub_STATEMENTS < <( printf '%s' "$__caseEsac__SEMICOLON_STATEMENT" )
                                                local __caseEsac__AND_sub_STATEMENT=''
                                                for __caseEsac__AND_sub_STATEMENT in "${__caseEsac__AND_sub_STATEMENTS[@]}"
                                                do
                                                  __caseEsac__AND_STATEMENTS+=("$__caseEsac__AND_sub_STATEMENT")
                                                done
                                              done
                                              
                                              # Finally, split on ||. Ok. Well, actually, we just split on '|'. Yay IFS.
                                              local __caseEsac__AND_STATEMENT=''
                                              for __caseEsac__AND_STATEMENT in "${__caseEsac__AND_STATEMENTS[@]}"
                                              do
                                                declare -a __caseEsac__PIPE_sub_STATEMENTS=()
                                                IFS='|' read -a __caseEsac__PIPE_sub_STATEMENTS < <( printf '%s' "$__caseEsac__AND_STATEMENT" )
                                                local __caseEsac__PIPE_sub_STATEMENT=''
                                                for __caseEsac__PIPE_sub_STATEMENT in "${__caseEsac__PIPE_sub_STATEMENTS[@]}"
                                                do
                                                  CASE_ESAC_LOC_BASH_STATEMENTS+=("$__caseEsac__PIPE_sub_STATEMENT")
                                                done
                                              done
                                              
                                              # If an array name was provided, load it up with these values (appends)
                                              if [ -n "$2" ]
                                              then
                                                eval "$2+=(\"\${CASE_ESAC_LOC_BASH_STATEMENTS[@]}\")"
                                              fi
                                            ## @
                              
                                                ;;
                                            "simpleLocals")
                                            ## @command caseEsac -- file processors localVariablePrefixes loaders simpleLocals
                                              # Our responsibility is to search for locals and add to these arrays:
                                              # - DISCOVERED_LOCAL_VARIABLES
                                              # - LOCAL_VARIABLE_REPLACEMENT_NAMES
                                              
                                              CASE_ESAC_FIND_LOCAL_REGEX_GENERIC='^[[:space:]]*local[[:space:]]([^=]*)[=]*(.*)'
                                              CASE_ESAC_FIND_LOCAL_REGEX_GENERIC_LOCAL_NAME=1
                                              
                                              local __caseEsac__simpleLocalLoader_LINE=''
                                              while IFS="" read -r __caseEsac__simpleLocalLoader_LINE || [ -n "$__caseEsac__simpleLocalLoader_LINE" ]
                                              do
                                                # Skip :shared:
                                                [[ "$__caseEsac__simpleLocalLoader_LINE" = *"$CASE_ESAC_LOCALS_PRESERVE_COMMENT"* ]] && continue
                                              
                                                # Get all of the split up BASH statements on this line (e.g. could have a ; or && or || on this line)
                                                declare -a __caseEsac__simpleLocalLoader_STATEMENTS=()
                                                caseEsac -- file processors localVariablePrefixes loaders getStatements "$__caseEsac__simpleLocalLoader_LINE" __caseEsac__simpleLocalLoader_STATEMENTS
                                              
                                                # Look at each statement and look for a `local` declaration (optionally with an assignment)
                                                local __caseEsac__simpleLocalLoader_STATEMENT=''
                                                for __caseEsac__simpleLocalLoader_STATEMENT in "${__caseEsac__simpleLocalLoader_STATEMENTS[@]}"
                                                do
                                                  if [[ "$__caseEsac__simpleLocalLoader_STATEMENT" =~ $CASE_ESAC_FIND_LOCAL_REGEX_GENERIC ]]
                                                  then
                                                    local __caseEsac__simpleLocalLoader_LOCAL_NAME="${BASH_REMATCH[$CASE_ESAC_FIND_LOCAL_REGEX_GENERIC_LOCAL_NAME]}"
                                              
                                                    # Is this a local that we're already found? Skip if so.
                                                    local __caseEsac__simpleLocalLoader_LOCAL_ALREADY_FOUND=false
                                              
                                                    # Look in the local list
                                                    local __caseEsac__simpleLocalLoader_previouslyDetectedLocalName=''
                                                    eval "
                                                      for __caseEsac__simpleLocalLoader_previouslyDetectedLocalName in \"\${LOCALS_FOR_$THIS_PARSE_CONTEXT[@]}\"
                                                      do
                                                        if [ \"\$__caseEsac__simpleLocalLoader_previouslyDetectedLocalName\" = \"\$__caseEsac__simpleLocalLoader_LOCAL_NAME\" ]
                                                        then
                                                          __caseEsac__simpleLocalLoader_LOCAL_ALREADY_FOUND=true
                                                          break
                                                        fi
                                                      done
                                                    "
                                              
                                                    # But look in the replacement list too, this could legit be a local that we already replaced
                                                    if [ "$__caseEsac__simpleLocalLoader_LOCAL_ALREADY_FOUND" = false ]
                                                    then
                                                      local __caseEsac__simpleLocalLoader_previouslyDetectedLocalName=''
                                                      eval "
                                                        for __caseEsac__simpleLocalLoader_previouslyDetectedLocalName in \"\${REPLACEMENTS_FOR_$THIS_PARSE_CONTEXT[@]}\"
                                                        do
                                                          if [ \"\$__caseEsac__simpleLocalLoader_previouslyDetectedLocalName\" = \"\$__caseEsac__simpleLocalLoader_LOCAL_NAME\" ]
                                                          then
                                                            __caseEsac__simpleLocalLoader_LOCAL_ALREADY_FOUND=true
                                                            break
                                                          fi
                                                        done
                                                      "
                                                    fi
                                              
                                                    # Hey, look! A new variable in this statement / line! Let's record it! Along with whatever new name we should give it.
                                                    if [ "$__caseEsac__simpleLocalLoader_LOCAL_ALREADY_FOUND" = false ]
                                                    then
                                                      __caseEsac__simpleLocalLoader_LOCAL_REPLACEMENT_NAME=''
                                                      # $1 Variable type: TEXT, ARRAY, or INTEGER
                                                      # $2 Variable name
                                                      # $3 Variable value, if any
                                                      # $4 Output variable for new variable name
                                                      # TODO update to not accept the value, that's cute but really completely unnecessary
                                                      caseEsac -- getLocalVariableReplacementName TEXT "$__caseEsac__simpleLocalLoader_LOCAL_NAME" "" __caseEsac__simpleLocalLoader_LOCAL_REPLACEMENT_NAME
                                              
                                                      if [ -n "$__caseEsac__simpleLocalLoader_LOCAL_REPLACEMENT_NAME" ]
                                                      then
                                                        eval "LOCALS_FOR_$THIS_PARSE_CONTEXT+=(\"\$__caseEsac__simpleLocalLoader_LOCAL_NAME\")"
                                                        eval "REPLACEMENTS_FOR_$THIS_PARSE_CONTEXT+=(\"\$__caseEsac__simpleLocalLoader_LOCAL_REPLACEMENT_NAME\")"
                                                      fi
                                                    fi
                                                  fi
                                                done
                                              done < <( printf '%s' "$1" )
                                            ## @
                              
                                                ;;
                                            *)
                                              echo "Unknown 'caseEsac -- file processors localVariablePrefixes loaders' command: $__caseEsac__mainCliCommands_command6" >&2
                                              return 1
                                              ;;
                                          esac
                                ## @
                    
                                    ;;
                                "replacers")
                                ## @command caseEsac -- file processors localVariablePrefixes replacers
                                          local __caseEsac__mainCliCommandDepth="6"
                                          __caseEsac__mainCliCommands+=("$1")
                                          local __caseEsac__mainCliCommands_command6="$1"
                                          shift
                                          case "$__caseEsac__mainCliCommands_command6" in
                                            "dollarVariables")
                                            ## @command caseEsac -- file processors localVariablePrefixes replacers dollarVariables
                                              
                                              local __caseEsac__dollarVariableReplacer_VARIABLE_TO_REPLACE_INDEX=''
                                              eval "
                                                for __caseEsac__dollarVariableReplacer_VARIABLE_TO_REPLACE_INDEX in \"\${!LOCALS_FOR_$THIS_PARSE_CONTEXT[@]}\"
                                                do
                                                  local __caseEsac__dollarVariableReplacer_VARIABLE_TO_REPLACE=\"\${LOCALS_FOR_$THIS_PARSE_CONTEXT[\$__caseEsac__dollarVariableReplacer_VARIABLE_TO_REPLACE_INDEX]}\"
                                                  local __caseEsac__dollarVariableReplacer_REPLACEMENT_NAME=\"\${REPLACEMENTS_FOR_$THIS_PARSE_CONTEXT[\$__caseEsac__dollarVariableReplacer_VARIABLE_TO_REPLACE_INDEX]}\"
                                              
                                                  if [[ \"\$1\" =~ ^(.*)\\\$([{]?)([\!\#]?)\$__caseEsac__dollarVariableReplacer_VARIABLE_TO_REPLACE([^a-zA-Z0-9_]*)(.*)\$ ]]
                                                  then
                                                    printf '%s' \"\${BASH_REMATCH[1]}\\\$\${BASH_REMATCH[2]}\${BASH_REMATCH[3]}\${__caseEsac__dollarVariableReplacer_REPLACEMENT_NAME}\${BASH_REMATCH[4]}\${BASH_REMATCH[5]}\"
                                                    # printf '%s' \"\$1\"
                                                    return 0 # we can do other variables in the next round! we'll be called multiple times per line if we make changes.
                                                  fi
                                                done
                                              "
                                              
                                              # We didn't return, just give back the same line
                                              printf '%s' "$1"
                                            ## @
                              
                                                ;;
                                            "localDeclarationVariables")
                                            ## @command caseEsac -- file processors localVariablePrefixes replacers localDeclarationVariables
                                              
                                              local __caseEsac__dollarVariableReplacer_VARIABLE_TO_REPLACE_INDEX=''
                                              eval "
                                                for __caseEsac__dollarVariableReplacer_VARIABLE_TO_REPLACE_INDEX in \"\${!LOCALS_FOR_$THIS_PARSE_CONTEXT[@]}\"
                                                do
                                                  local __caseEsac__dollarVariableReplacer_VARIABLE_TO_REPLACE=\"\${LOCALS_FOR_$THIS_PARSE_CONTEXT[\$__caseEsac__dollarVariableReplacer_VARIABLE_TO_REPLACE_INDEX]}\"
                                                  local __caseEsac__dollarVariableReplacer_REPLACEMENT_NAME=\"\${REPLACEMENTS_FOR_$THIS_PARSE_CONTEXT[\$__caseEsac__dollarVariableReplacer_VARIABLE_TO_REPLACE_INDEX]}\"
                                              
                                                  if [[ \"\$1\" =~ ^(.*)local[[:space:]]\$__caseEsac__dollarVariableReplacer_VARIABLE_TO_REPLACE([^a-zA-Z0-9_]*)(.*)\$ ]]
                                                  then
                                                    printf '%s' \"\${BASH_REMATCH[1]}local \$__caseEsac__dollarVariableReplacer_REPLACEMENT_NAME\${BASH_REMATCH[2]}\${BASH_REMATCH[3]}\"
                                                    return 0
                                                  fi
                                                done
                                              "
                                              
                                              # We didn't return, just give back the same line
                                              printf '%s' "$1"
                                              
                                                # if [[ "$1" =~ ^(.*)local[[:space:]]$__caseEsac__dollarVariableReplacer_VARIABLE_TO_REPLACE[=](.*)$ ]]
                                                # then
                                                #   printf '%s' "${BASH_REMATCH[1]}local $__caseEsac__dollarVariableReplacer_REPLACEMENT_NAME=${BASH_REMATCH[2]}"
                                                #   return 0
                                            ## @
                              
                                                ;;
                                            *)
                                              echo "Unknown 'caseEsac -- file processors localVariablePrefixes replacers' command: $__caseEsac__mainCliCommands_command6" >&2
                                              return 1
                                              ;;
                                          esac
                                ## @
                    
                                    ;;
                                *)
                                  echo "Unknown 'caseEsac -- file processors localVariablePrefixes' command: $__caseEsac__mainCliCommands_command5" >&2
                                  return 1
                                  ;;
                              esac
                      ## @
            
                          ;;
                      "lovelyErrors")
                      ## @command caseEsac -- file processors lovelyErrors
                        # Come back to errors
                        printf '%s' "$1" | sed "s/$CASE_ESAC_ERROR_KEYWORD/: # ERRORS DISABLED/g"
                        return 0
                        
                        local __caseEsac_file_processors_lovelyErrors_newLine=$'\n'
                        local __caseEsac_file_processors_lovelyErrors_outputContent=''
                        local __caseEsac_file_processors_lovelyErrors_inputFileLine=''
                        while IFS="" read -r __caseEsac_file_processors_lovelyErrors_inputFileLine || [ -n "$__caseEsac_file_processors_lovelyErrors_inputFileLine" ]
                        do
                          if [[ "$__caseEsac_file_processors_lovelyErrors_inputFileLine" =~ [[:space:]]*$CASE_ESAC_ERROR_KEYWORD[[:space:]]*([0-9]+?)[[:space:]]*(.*) ]] || [[ "$__caseEsac_file_processors_lovelyErrors_inputFileLine" =~ [[:space:]]*$CASE_ESAC_ERROR_KEYWORD[[:space:]]* ]]
                          then
                            shellpen pen :error errorSource
                        
                            if [[ "$__caseEsac_file_processors_lovelyErrors_inputFileLine" =~ [[:space:]]*$CASE_ESAC_ERROR_KEYWORD[[:space:]]*([0-9]+?)[[:space:]]*(.*) ]]
                            then
                              declare -i __caseEsac_file_processors_lovelyErrors_returnCode="${BASH_REMATCH[1]}"
                              [ "$__caseEsac_file_processors_lovelyErrors_returnCode" = 0 ] && __caseEsac_file_processors_lovelyErrors_returnCode=1
                              local __caseEsac_file_processors_lovelyErrors_errorMessages="${BASH_REMATCH[2]}"
                              [ -z "$__caseEsac_file_processors_lovelyErrors_errorMessages" ] && __caseEsac_file_processors_lovelyErrors_errorMessages="\"$CASE_ESAC_ERROR_MESSAGE\""
                            else
                              # !error called without parameters (the extra matcher exists to help BASH 3.2.57 on Mac)
                              declare -i __caseEsac_file_processors_lovelyErrors_returnCode=1
                              local __caseEsac_file_processors_lovelyErrors_errorMessages=""
                            fi
                        
                            __caseEsac_file_processors_lovelyErrors_errorSourceCode=""
                        
                            if [ -n "$CASE_ESAC_ERROR_PREFIX" ]
                            then
                              :error stderr "'%s'" "\"$CASE_ESAC_ERROR_PREFIX\""
                            fi
                        
                            local __caseEsac_file_processors_lovelyErrors_errorType=''
                            if [[ "$__caseEsac_file_processors_lovelyErrors_errorMessages" =~ [[:space:]]*(\[[a-zA-Z0-9 ]+\])*[[:space:]]*(.*) ]]
                            then
                              __caseEsac_file_processors_lovelyErrors_errorType="${BASH_REMATCH[1]}"
                              __caseEsac_file_processors_lovelyErrors_errorMessages="${BASH_REMATCH[2]}"
                              if [ -n "$__caseEsac_file_processors_lovelyErrors_errorType" ]
                              then
                                :error 
                                __caseEsac_file_processors_lovelyErrors_errorSourceCode+="printf '%s' \" $__caseEsac_file_processors_lovelyErrors_errorType \" >&2${__caseEsac_file_processors_lovelyErrors_newLine}"
                              fi
                            fi
                        
                            :error local __errorMessage__
                            :error for __errorMessage__ in "$__caseEsac_file_processors_lovelyErrors_errorMessages"
                              :error stderr '$__errorMessage__'
                            :error done
                            :error if [ "\"$CASE_ESAC_SILENCE_STACKTRACE_VARIABLE\"" != true ]
                              :error stderr
                              :error stderr "Stacktrace:"
                              :error stderr
                              :error if [ -n "\"$CASE_ESAC_SILENCE_STACKTRACE_SKIP_VARIABLE\"" ]
                                :error int stacktrace_levelsToSkip "$CASE_ESAC_SILENCE_STACKTRACE_SKIP_VARIABLE"
                              :error else
                                :error int stacktrace_levelsToSkip=3 # default
                              :error fi
                              :error if [ -n "\"$CASE_ESAC_SILENCE_STACKTRACE_MAX_DEPTH_VARIABLE\"" ]
                                :error int stacktrace_maxDepth "$CASE_ESAC_SILENCE_STACKTRACE_MAX_DEPTH_VARIABLE"
                              :error else
                                :error int stacktrace_maxDepth=100 # default
                              :error fi
                              :error int stacktrace_i=1
                              :error int stacktrace_stackIndex '$stacktrace_levelsToSkip'
                              :error while [ '"$stacktrace_stackIndex"' -lt '"${#BASH_SOURCE[0]}"' ] AND [ '$stacktrace_i' -lt '$stacktrace_maxDepth' ]
                                
                                :error int lineNumber '${BASH_LINENO[$(( stacktrace_stackIndex - 1 ))]}'
                                :error local sourceFile '${BASH_SOURCE[$stacktrace_stackIndex]}'
                                :error local functionName '${FUNCNAME[$stacktrace_stackIndex]}'
                                
                                :error if [ -n '"$functionName"' ]
                        
                                  :error if [ "\"$CASE_ESAC_SILENCE_STACKTRACE_FILE_LOC_VARIABLE\"" != true ]
                                    :error if [ '$lineNumber' -eq 0 ]
                                      :error local sourceCode '$( sed "1q;d" "$sourceFile" | sed "s/^ *//" )'
                                    :error else
                                      :error local sourceCode '$( sed "${lineNumber}q;d" "$sourceFile" | sed "s/^ *//" )'
                                    :error fi
                                  :error fi
                        
                                  :error stderr '${sourceFile}:${lineNumber} ${functionName}()'
                        
                                  :error if [ "\"$CASE_ESAC_SILENCE_STACKTRACE_FILE_LOC_VARIABLE\"" != true ]
                                    :error stderr '$sourceCode'
                                    :error stderr
                                  :error fi
                        
                                :error else
                                  :error break
                                :error fi
                                
                                :error ++ stacktrace_i
                                :error ++ stacktrace_stackIndex
                              :error done
                            :error fi
                          
                            :error return $__caseEsac_file_processors_lovelyErrors_returnCode
                            
                            __caseEsac_file_processors_lovelyErrors_outputContent+="${__caseEsac_file_processors_lovelyErrors_newLine}# ERROR CODE BEGIN${__caseEsac_file_processors_lovelyErrors_newLine}"
                            __caseEsac_file_processors_lovelyErrors_outputContent+="$( :error code )"
                            __caseEsac_file_processors_lovelyErrors_outputContent+="${__caseEsac_file_processors_lovelyErrors_newLine}# ERROR CODE END${__caseEsac_file_processors_lovelyErrors_newLine}"
                        
                            :error putAway withSource
                          elif [[ "$__caseEsac_file_processors_lovelyErrors_inputFileLine" = *"$CASE_ESAC_ERROR_KEYWORD"* ]]
                          then
                            caseEsac -- errors generalError '%s\n%s' "Invalid $CASE_ESAC_ERROR_KEYWORD syntax: $__caseEsac_file_processors_lovelyErrors_inputFileLine" "Command: caseEsac ${__caseEsac__originalCliCommands[*]}"
                            return 1
                          else
                            __caseEsac_file_processors_lovelyErrors_outputContent+="${__caseEsac_file_processors_lovelyErrors_inputFileLine}${__caseEsac_file_processors_lovelyErrors_newLine}"
                          fi
                        done < <( printf '%s' "$1" )
                        
                        printf '%s' "$__caseEsac_file_processors_lovelyErrors_outputContent"
                      ## @
            
                          ;;
                      "originalArguments")
                      ## @command caseEsac -- file processors originalArguments
                        printf '%s' "$1" | sed "s/$CASE_ESAC_ARGUMENTS_KEYWORD/$CASE_ESAC_ARGUMENTS_VARIABLE/g"
                      ## @
            
                          ;;
                      "partialIncludes")
                      ## @command caseEsac -- file processors partialIncludes
                        local __caseEsac_file_processors_partialIncludes_newLine=$'\n'
                        local __caseEsac_file_processors_partialIncludes_outputContent=''
                        local __caseEsac_file_processors_partialIncludes_inputFileLine=''
                        while IFS="" read -r __caseEsac_file_processors_partialIncludes_inputFileLine || [ -n "$__caseEsac_file_processors_partialIncludes_inputFileLine" ]
                        do
                          if [[ "$__caseEsac_file_processors_partialIncludes_inputFileLine" =~ ^[[:space:]]*$CASE_ESAC_INCLUDE_KEYWORD[[:space:]](.*)$ ]]
                          then
                            __caseEsac_file_processors_partialIncludes_partial="${BASH_REMATCH[1]}"
                            local __caseEsac_file_processors_partialIncludes_partialFilePath=''
                            if caseEsac -- file findPartialPath "$__caseEsac_file_processors_partialIncludes_partial" __caseEsac_file_processors_partialIncludes_partialFilePath
                            then
                              local __caseEsac_file_processors_partialIncludes_partialContent="$(<"$__caseEsac_file_processors_partialIncludes_partialFilePath")${__caseEsac_file_processors_partialIncludes_newLine}"
                              __caseEsac_file_processors_partialIncludes_outputContent+="$__caseEsac_file_processors_partialIncludes_partialContent"
                            else
                              caseEsac -- errors generalError '%s\n%s' "Could not find path to partial '$__caseEsac_file_processors_partialIncludes_partial' defined in '$CASE_ESAC_SOURCE_FILE_PATH'" "Command: caseEsac ${__caseEsac__originalCliCommands[*]}"
                              return 1
                            fi
                          else
                            __caseEsac_file_processors_partialIncludes_outputContent+="${__caseEsac_file_processors_partialIncludes_inputFileLine}${__caseEsac_file_processors_partialIncludes_newLine}"
                          fi
                        done < <( printf '%s' "$1" )
                        
                        printf '%s' "$__caseEsac_file_processors_partialIncludes_outputContent"
                      ## @
            
                          ;;
                      *)
                        echo "Unknown 'caseEsac -- file processors' command: $__caseEsac__mainCliCommands_command4" >&2
                        return 1
                        ;;
                    esac
              ## @
      
                  ;;
              *)
                echo "Unknown 'caseEsac -- file' command: $__caseEsac__mainCliCommands_command3" >&2
                return 1
                ;;
            esac
        ## @
  
            ;;
        "function")
        ## @command caseEsac -- function
            local __caseEsac__mainCliCommandDepth="3"
            __caseEsac__mainCliCommands+=("$1")
            local __caseEsac__mainCliCommands_command3="$1"
            shift
            case "$__caseEsac__mainCliCommands_command3" in
              "addToCommandList")
              ## @command caseEsac -- function addToCommandList
                caseEsac -- appendText "$CASE_ESAC_COMMAND_LIST_VARIABLE+=(\"$1\")"
              ## @
      
                  ;;
              "footer")
              ## @command caseEsac -- function footer
                
              ## @
      
                  ;;
              "header")
              ## @command caseEsac -- function header
                [ -f "$CASE_ESAC_SOURCE_ROOT_PATH/$CASE_ESAC_FUNCTION_HEADER" ] && caseEsac -- appendFile "$CASE_ESAC_SOURCE_ROOT_PATH/$CASE_ESAC_FUNCTION_HEADER"
              ## @
      
                  ;;
              "locals")
              ## @command caseEsac -- function locals
                caseEsac -- appendText "declare -a $CASE_ESAC_ARGUMENTS_VARIABLE=(\"\$@\") # :shared:"
                caseEsac -- appendText "declare -a $CASE_ESAC_COMMAND_LIST_VARIABLE=(\"$CASE_ESAC_FUNCTION_NAME\") # :shared:"
              ## @
      
                  ;;
              "popCommandList")
              ## @command caseEsac -- function popCommandList
                caseEsac -- appendText "unset $CASE_ESAC_COMMAND_LIST_VARIABLE[\$(( \${#$CASE_ESAC_COMMAND_LIST_VARIABLE[@]} - 1 ))]"
                caseEsac -- appendText "$CASE_ESAC_COMMAND_LIST_VARIABLE=(\"$CASE_ESAC_COMMAND_LIST_VARIABLE[@]\")"
              ## @
      
                  ;;
              *)
                echo "Unknown 'caseEsac -- function' command: $__caseEsac__mainCliCommands_command3" >&2
                return 1
                ;;
            esac
        ## @
  
            ;;
        "gatherEligibleDirectoryItems")
        ## @command caseEsac -- gatherEligibleDirectoryItems
          ## $1 Directory path
          ## > Responsible for populating `CASE_ESAC_DIRECTORY_ITEMS`
          
          CASE_ESAC_DIRECTORY_ITEMS=()
          
          local __caseEsac__directoryItem=''
          while read -rd '' __caseEsac__directoryItem
          do
          
            [ "$__caseEsac__directoryItem" = "$1" ] && continue
          
           CASE_ESAC_DIRECTORY_ITEMS+=("$__caseEsac__directoryItem")
          
          done < <( find "$1" -maxdepth 1 \( -type d -not -name ".*" -not -path "*/.*" -or -type f -name "*.sh" -not -name ".*" -not -path "*/.*" \) -print0 )
        ## @
  
            ;;
        "getLocalVariableReplacementName")
        ## @command caseEsac -- getLocalVariableReplacementName
          ## $1 Variable type: TEXT, ARRAY, or INTEGER
          ## $2 Variable name
          ## $3 Variable value, if any
          ## $4 Output variable for new variable name
          ##
          ## Default implementation prefixes using `CASE_ESAC_SOURCE_RELATIVE_FILE_PATH`
          
          local __caseEsac__getLocalVariableReplacementName_newVariableName=""
          
          FULL_COMMAND=("${CASE_ESAC_FULL_COMMAND_NAME[@]}")
          COMMANDS=("${CASE_ESAC_FULL_COMMAND_NAME[@]:1}")
          LOCAL_TYPE="$1"
          LOCAL_NAME="$2"
          LOCAL_VALUE="$3"
          
          # Use :shared: to skip the locals parser
          
          # Replace !fn !command etc
          caseEsac -- parseText "$CASE_ESAC_LOCALS_PREFIX # :shared:" __caseEsac__getLocalVariableReplacementName_newVariableName
          __caseEsac__getLocalVariableReplacementName_newVariableName="${__caseEsac__getLocalVariableReplacementName_newVariableName% # :shared:}"
          
          # Evaluate the local prefix code (we printf the result)
          eval "__caseEsac__getLocalVariableReplacementName_newVariableName=\"$__caseEsac__getLocalVariableReplacementName_newVariableName\""
          
          # Add the local
          __caseEsac__getLocalVariableReplacementName_newVariableName+="$LOCAL_NAME"
          
          unset FULL_COMMAND
          unset COMMAND
          unset LOCAL_TYPE
          unset LOCAL_NAME
          unset LOCAL_VALUE
          
          # Replace any non alphanumeric characters with _
          __caseEsac__getLocalVariableReplacementName_newVariableName="${__caseEsac__getLocalVariableReplacementName_newVariableName//[^a-zA-Z0-9_]/_}"
          
          printf -v "$4" '%s' "$__caseEsac__getLocalVariableReplacementName_newVariableName"
        ## @
  
            ;;
        "noArgumentsProvided")
        ## @command caseEsac -- noArgumentsProvided
          # - error "No arguments"
          # caseEsac -- appendText "$CASE_ESAC_ERROR_NO_ARGUMENTS"
          - error "$CASE_ESAC_FUNCTION_NAME: Arguments are required but none were provided"
        ## @
  
            ;;
        "parseArguments")
        ## @command caseEsac -- parseArguments
          while [ $# -gt 0 ]
          do
            if [ "$1" = "--src" ]; then # -s
              shift; CASE_ESAC_SOURCE_ROOT_PATH="$1"
            elif [ "$1" = "--out" ]; then # -o
              shift; CASE_ESAC_OUTPUT_FILE_PATH="$1"
            elif [ "$1" = "--fn" ]; then # -f
              shift; CASE_ESAC_FUNCTION_NAME="$1"
            elif [ "$1" = "-i" ] || [ "$1" == "--index" ]; then 
              shift; CASE_ESAC_COMMAND_ROOT_FILE="$1"
            elif [ "$1" = "-h" ] || [ "$1" == "--header" ]; then 
              shift; CASE_ESAC_FILE_HEADER="$1"
            elif [ "$1" = "-f" ] || [ "$1" == "--footer" ]; then 
              shift; CASE_ESAC_FILE_FOOTER="$1"
            elif [ "$1" = "-l" ] || [ "$1" = "--locals-prefix" ]; then
              shift; CASE_ESAC_LOCALS_PREFIX="$1"
            else
              echo "Unknown argument(s) provided to 'caseEsac compile': $*" >&2
              return 1
            fi
            shift
          done
        ## @
  
            ;;
        "parseText")
        ## @command caseEsac -- parseText
          caseEsac -- file parse "" "$@"
        ## @
  
            ;;
        "previouslyReplacedLocalName")
        ## @command caseEsac -- previouslyReplacedLocalName
          ## $1 Variable type: TEXT, ARRAY, or INTEGER
          ## $2 Variable name
          ## $3 Variable value, if any
          ##
          ## Default implementation prefixes using `CASE_ESAC_SOURCE_RELATIVE_FILE_PATH`
          
          [[ "$2" = *"$( caseEsac -- getLocalVariableReplacementName "$1" "" "$3" )"* ]]
        ## @
  
            ;;
        "startCommandCase")
        ## @command caseEsac -- startCommandCase
          - local "__${CASE_ESAC_FUNCTION_NAME}__${CASE_ESAC_COMMAND_DEPTH}" '$1'
          - shift
          - case "\$__${CASE_ESAC_FUNCTION_NAME}__${CASE_ESAC_COMMAND_DEPTH}"
        ## @
  
            ;;
        "wildcardOption")
        ## @command caseEsac -- wildcardOption
          - option '*'
            caseEsac -- commandNotFound
            - ::
        ## @
  
            ;;
        *)
          echo "Unknown 'caseEsac --' command: $__caseEsac__mainCliCommands_command2" >&2
          return 1
          ;;
      esac
    ## @

        ;;
    "compile")
    ## @command caseEsac compile
      # TODO add !script to point to the filename of the generated output file
      # TODO update all examples/*/compile.sh to delete result.sh first
      
      # Move to partial
      
      PARSE_CONTEXT_ID="${PARSE_CONTEXT_ID:-0}" # Keep this as a number. But change 'PARSE' to CASE_ESAC log.log
      (( PARSE_CONTEXT_ID++ ))
      
      caseEsac -- parseArguments "$@" || return $?
      
      # This could be another partial
      
      if [ -z "$CASE_ESAC_SOURCE_ROOT_PATH" ]
      then
        echo "'caseEsac compile' requires --src, none provided" >&2
        return 1
      fi
      
      if [ -z "$CASE_ESAC_OUTPUT_FILE_PATH" ]
      then
        echo "'caseEsac compile' requires --out, none provided" >&2
      fi
      
      if [ -z "$CASE_ESAC_FUNCTION_NAME" ]
      then
        local __csaeEsac__outputFileName="${CASE_ESAC_OUTPUT_FILE_PATH##*/}"
        CASE_ESAC_FUNCTION_NAME="${__csaeEsac__outputFileName%%\.*}"
      fi
      
      
      
      #
      
      CASE_ESAC_FULL_COMMAND_NAME=("$CASE_ESAC_FUNCTION_NAME")
      
      [ -d "$CASE_ESAC_SOURCE_ROOT_PATH" ] || { echo "caseEsac error: provided input must be a directory '$CASE_ESAC_SOURCE_ROOT_PATH'" >&2; return 1; }
      
      declare -i CASE_ESAC_COMMAND_DEPTH=1
      declare -a CASE_ESAC_DIRECTORY_ITEMS=()
      
      caseEsac -- gatherEligibleDirectoryItems "$CASE_ESAC_SOURCE_ROOT_PATH"
      
      [ "${#CASE_ESAC_DIRECTORY_ITEMS[@]}" -eq 0 ] && { echo "caseEsac error: provided input directory empty '$CASE_ESAC_SOURCE_ROOT_PATH'" >&2; return 1; }
      
      # Move above into partials
      
      shellpen -
      
      caseEsac -- appendText "$CASE_ESAC_HASHBANG\n"
      
      caseEsac -- file header
      
      - function "$CASE_ESAC_FUNCTION_NAME"
      
        caseEsac -- function header
        
        caseEsac -- function locals
      
        if [ -f "$CASE_ESAC_SOURCE_ROOT_PATH/$CASE_ESAC_COMMAND_ROOT_FILE" ]
        then
          caseEsac -- appendFile "$CASE_ESAC_SOURCE_ROOT_PATH/$CASE_ESAC_COMMAND_ROOT_FILE"
        fi
      
        - if [ '$#' -eq 0 ]
          caseEsac -- noArgumentsProvided
        - else
      
          caseEsac -- startCommandCase
      
            # Kick off the directory traversal!
            local __caseEsac__directoryItem=''
            for __caseEsac__directoryItem in "${CASE_ESAC_DIRECTORY_ITEMS[@]}"
            do
              if [ -f "$__caseEsac__directoryItem" ]
              then
                caseEsac -- caseOptionForFile "$__caseEsac__directoryItem"
              elif [ -d "$__caseEsac__directoryItem" ]
              then
                caseEsac -- caseForDirectory "$__caseEsac__directoryItem"
              fi
            done
      
          caseEsac -- wildcardOption
      
          - esac
      
        - fi
        caseEsac -- function footer
      - }
      
      caseEsac -- file footer
      
      - main "$CASE_ESAC_FUNCTION_NAME"
      
      - code > "$CASE_ESAC_OUTPUT_FILE_PATH"
    ## @

        ;;
    "config")
    ## @command caseEsac config
      caseEsac -- parseArguments "$@" || return $?
      
      echo "Version: $CASE_ESAC_VERSION"
      echo "Index File: $CASE_ESAC_COMMAND_ROOT_FILE"
    ## @

        ;;
    "--version")
    ## @command caseEsac --version
      echo "caseEsac compiler version $CASE_ESAC_VERSION"
    ## @

        ;;
    *)
      echo "Unknown 'caseEsac' command: $__caseEsac__mainCliCommands_command1" >&2
      ;;
  esac

}

[ "${BASH_SOURCE[0]}" = "$0" ] && "caseEsac" "$@"

